<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>虚幻引擎用SceneViewExtension实现简单后处理效果</title>
    <link href="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/"/>
    <url>/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前两篇文章介绍了虚幻引擎中计算管线和图形管线的调用流程，但示例中仅在某个 <code>Actor</code> 的 <code>BeginPlay()</code> 中调用了一次。如果希望<strong>在每一帧都执行这个自定义管线</strong>，又该如何实现呢？</p><p>这时就需要借助 <code>SceneViewExtension</code>。<code>SceneViewExtension</code> 为我们提供了渲染流程中多个阶段的 Hook，既涵盖<strong>游戏线程</strong>，也包含<strong>渲染线程</strong>。通过重写对应的虚函数，我们可以实现例如：</p><ol><li>修改视口（View）的相关属性；</li><li>获取RDG中的相关资源，例如<code>GBuffer</code>、<code>SceneColor</code>等;</li><li>注入并执行自定义着色器；</li></ol><p>然而，正如其名字所暗示的那样，<code>SceneViewExtension</code> 本质上只是一个“扩展点”，它并不会改变 Unreal Engine 内部真正的光照模型。即使我们在某个 Hook 中基于 GBuffer 重新计算了一套完整的光照结果，也只是<strong>在现有渲染结果之上额外进行了一次计算</strong>，并不会影响引擎内部的光照流程本身。<br>如果希望真正替换或重写光照模型，就必须修改 Unreal Engine 的渲染源码。相比之下，这一点确实要比 URP 麻烦不少。</p><p>在理解了这一限制之后，<code>SceneViewExtension</code> 更适合用于一些<strong>非侵入式的渲染扩展</strong>。因此，本文将介绍如何利用 <code>SceneViewExtension</code> 实现一个简单的后处理效果——一个“丐版”的复古电视机滤镜。本文使用的虚幻引擎版本仍然是 <strong>5.7</strong>。</p><p>代码参考了Github上的一个模板：<a href="https://github.com/A57R4L/SceneViewExtensionTemplate">SceneViewExtensionTemplate</a></p><p>本项目的源码：<a href="https://github.com/OnikataHoshio/LearnRDG">OnikataHoshio&#x2F;LearnRDG</a></p><h3 id="配置SVE插件"><a href="#配置SVE插件" class="headerlink" title="配置SVE插件"></a>配置SVE插件</h3><h4 id="配置虚拟路径映射"><a href="#配置虚拟路径映射" class="headerlink" title="配置虚拟路径映射"></a>配置虚拟路径映射</h4><p>打开虚幻引擎，依次点击 <strong>编辑 → 插件 → 添加</strong>，创建一个新的插件，这里将其命名为 <strong>RetroTV</strong>。<br>创建完成后，插件结构如下图所示：</p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/IMG-20260131211504097.png" class=""><p>随后打开生成的 <strong>C++ 项目</strong>，在 <code>RetroTV.cpp</code> 中为插件添加 <code>Shaders</code> 目录的<strong>虚拟路径映射</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FRetroTVModule::StartupModule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module</span><br>FString PluginShaderDir = FPaths::<span class="hljs-built_in">Combine</span>(FPaths::<span class="hljs-built_in">ProjectPluginsDir</span>(), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/RetroTV/Shaders&quot;</span>));<br><span class="hljs-built_in">AddShaderSourceDirectoryMapping</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Plugins/RetroTVShaders&quot;</span>), PluginShaderDir);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这一步配置，我们就可以将所有与该插件相关的 <code>.usf</code> 着色器文件，直接放在插件目录下的 <code>Shaders</code> 文件夹中，而不需要放入引擎或项目的全局 Shader 目录。最终的目录结构如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LearnRDG<br>|-Content<br>|-Plugins<br>|-RetroTV<br>|-Shaders<br>|-Source<br></code></pre></td></tr></table></figure><h4 id="配置模块依赖"><a href="#配置模块依赖" class="headerlink" title="配置模块依赖"></a>配置模块依赖</h4><p>接下来需要在 <code>RetroTV.Build.cs</code> 中配置插件所需的模块依赖与路径依赖。<br>其中，自定义着色器和 RDG 功能依赖于 <code>RenderCore</code>、<code>Renderer</code> 以及 <code>RHI</code> 模块；<code>Projects</code> 模块用于配置 Shader 的虚拟路径映射；而 <code>DeveloperSettings</code> 则用于辅助我们读取和引用部分配置或资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">var EngineDir = Path.<span class="hljs-built_in">GetFullPath</span>(Target.RelativeEnginePath);<br><br>PrivateIncludePaths.<span class="hljs-built_in">AddRange</span>(<br><span class="hljs-keyword">new</span> string[] &#123;<br><span class="hljs-comment">// ... add other private include paths required here ...</span><br><span class="hljs-comment">// Required to find PostProcessing includes f.ex. screenpass.h &amp; TranslucentPassResource.h</span><br>Path.<span class="hljs-built_in">Combine</span>(EngineDir, <span class="hljs-string">&quot;Source/Runtime/Renderer/Private&quot;</span>),<br>Path.<span class="hljs-built_in">Combine</span>(EngineDir, <span class="hljs-string">&quot;Source/Runtime/Renderer/Internal&quot;</span>)<br>&#125;<br>);<br><br>PrivateDependencyModuleNames.<span class="hljs-built_in">AddRange</span>(<br><span class="hljs-keyword">new</span> string[]<br>&#123;<br><span class="hljs-string">&quot;CoreUObject&quot;</span>,<br><span class="hljs-string">&quot;Engine&quot;</span>,<br><span class="hljs-string">&quot;Slate&quot;</span>,<br><span class="hljs-string">&quot;SlateCore&quot;</span>,<br><span class="hljs-comment">// ... add private dependencies that you statically link with here ...</span><br><span class="hljs-string">&quot;RenderCore&quot;</span>,<br><span class="hljs-string">&quot;Renderer&quot;</span>,<br><span class="hljs-string">&quot;RHI&quot;</span>,<br><span class="hljs-string">&quot;Projects&quot;</span>,<br><span class="hljs-string">&quot;DeveloperSettings&quot;</span><br>&#125;<br>);<br></code></pre></td></tr></table></figure><h4 id="修改RetroTV-uplugin"><a href="#修改RetroTV-uplugin" class="headerlink" title="修改RetroTV.uplugin"></a>修改RetroTV.uplugin</h4><p>打开<code>RetroTV.uplugin</code>，将<code>Modules</code> 中的 <code>LoadingPhase</code> 从 <code>Default</code> 修改为 <code>PostConfigInit</code>，否则可能会出现 <strong>Shader 在虚拟路径尚未建立之前就被编译</strong> 的问题，从而导致编译失败或路径无法解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-string">&quot;Modules&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;RetroTV&quot;</span>,<br><span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br><span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;PostConfigInit&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编写usf文件"><a href="#编写usf文件" class="headerlink" title="编写usf文件"></a>编写usf文件</h3><p>我希望实现一个“丐版”的复古电视风格效果，整体可以拆分为以下四个主要环节：</p><ol><li>镜头畸变；</li><li>电视机蒙版；</li><li>噪点；</li><li>扫描线。</li></ol><p>除此之外，还可以进一步加入诸如高斯模糊、UV 突变等效果。不过考虑到这只是一个用于练手和验证流程的小工程，本文中不会将实现设计得过于复杂。</p><p>此外，由于如何编写usf文件不是本篇文章的重点，因此直接给出相关代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Custom CS PostProcessing Shader</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Public/Platform.ush&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Private/Common.ush&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Private/ScreenPass.ush&quot;</span></span><br><br>Texture2D OriginalSceneColor;<br>Texture2D TVMaskTexture;<br>Texture2D ScanLineTexture;<br><br><span class="hljs-type">float</span> RetroScaleFactor;<br><span class="hljs-type">float</span> LensDistortionK1; <br><span class="hljs-type">float</span> LensDistortionK2; <br><br><span class="hljs-type">float</span> VignetteStart;  <br><span class="hljs-type">float</span> VignetteEnd; <br><span class="hljs-type">float</span> VignettePower;   <br><span class="hljs-type">float</span> VignetteIntensity;  <br><br><span class="hljs-type">float</span> ScanlineSpeed;<br><span class="hljs-type">float</span> ScanlineIntensity;<br><span class="hljs-type">float</span> ScanlineScale;<br><br><span class="hljs-built_in">SCREEN_PASS_TEXTURE_VIEWPORT</span>(SceneColorViewport)<br><br>RWTexture2D&lt;float4&gt; Output;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CalcaulateLuminance</span><span class="hljs-params">(float3 color)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dot</span>(color, <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.2126f</span>, <span class="hljs-number">0.7152f</span>, <span class="hljs-number">0.0722f</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetNoise</span><span class="hljs-params">(float2 p, <span class="hljs-type">float</span> offset)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">frac</span>(<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">dot</span>(p + offset, <span class="hljs-built_in">float2</span>(<span class="hljs-number">12.9898</span>, <span class="hljs-number">78.233</span>))) * <span class="hljs-number">43758.5453</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">HDRToLDR</span><span class="hljs-params">(float3 color)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> luma = <span class="hljs-built_in">CalcaulateLuminance</span>(color);<br>    <span class="hljs-keyword">return</span> luma / (<span class="hljs-number">1.0f</span> + luma); <br>&#125;<br><br><span class="hljs-function">float4 <span class="hljs-title">CalculateColorGrain</span><span class="hljs-params">(float3 hdrColor, float2 uv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> lumaLDR = <span class="hljs-built_in">HDRToLDR</span>(hdrColor);<br>    <br>    float2 seed = uv + View.StateFrameIndexMod8; <br>    <br>    float3 noise;<br>    noise.r = <span class="hljs-built_in">GetNoise</span>(seed , <span class="hljs-number">0.1337</span>);       <br>    noise.g = <span class="hljs-built_in">GetNoise</span>(seed , <span class="hljs-number">0.4242</span>);    <br>    noise.b = <span class="hljs-built_in">GetNoise</span>(seed , <span class="hljs-number">0.5342</span>);   <br><br>    <span class="hljs-type">float</span> strength = <span class="hljs-number">1.0</span> - <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">abs</span>(lumaLDR - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>);<br><br>    float3 grain = (noise - <span class="hljs-number">0.5f</span>) * strength * lumaLDR; <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">float4</span>(grain, <span class="hljs-number">1.0f</span>);<br>&#125;<br><br><span class="hljs-function">float2 <span class="hljs-title">CalculateDistortedUV</span><span class="hljs-params">(float2 screenCoord, <span class="hljs-type">float</span> viewAspect)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 p = screenCoord;<br>    p.x *= viewAspect;<br><br>    <span class="hljs-type">float</span> r2 = <span class="hljs-built_in">dot</span>(p, p);<br>    <span class="hljs-type">float</span> scale = <span class="hljs-number">1.0f</span> + LensDistortionK1 * r2 + LensDistortionK2 * (r2 * r2);<br>    float2 distortedP = p * scale;<br>    distortedP.x /= viewAspect;<br><br>    float2 distortedUV = (distortedP + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-keyword">return</span> distortedUV;<br>&#125;<br><br><span class="hljs-function">float4 <span class="hljs-title">CalculateDistortedColor</span><span class="hljs-params">(float2 distortedUV, <span class="hljs-type">float</span> viewAspect)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 uvMin = <span class="hljs-built_in">float2</span>(SceneColorViewport_ViewportMin) * SceneColorViewport_ExtentInverse + SceneColorViewport_ExtentInverse;<br>    float2 uvMax = <span class="hljs-built_in">float2</span>(SceneColorViewport_ViewportMin + SceneColorViewport_ViewportSize) * SceneColorViewport_ExtentInverse - SceneColorViewport_ExtentInverse;<br><br>    <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">any</span>(distortedUV &lt; uvMin) || <span class="hljs-built_in">any</span>(distortedUV &gt; uvMax);<br><br>    float2 safeUV = <span class="hljs-built_in">clamp</span>(distortedUV, uvMin, uvMax);<br>    float4 distortedColor = OriginalSceneColor.<span class="hljs-built_in">SampleLevel</span>(GlobalBilinearClampedSampler, safeUV, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (outside) distortedColor = <span class="hljs-built_in">float4</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> distortedColor;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CalculateVignette</span><span class="hljs-params">(float2 distortedUV)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 centeredUV = distortedUV * <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(centeredUV);<br><br>    <span class="hljs-type">float</span> vignette = <span class="hljs-built_in">smoothstep</span>(VignetteStart, VignetteEnd, dist);<br>    vignette = <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span> - vignette, VignettePower);<br>    vignette = <span class="hljs-built_in">lerp</span>(<span class="hljs-number">1.0f</span>, vignette, VignetteIntensity);<br>    <br>    <span class="hljs-keyword">return</span> vignette;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CalculateScanline</span><span class="hljs-params">(float2 uv)</span></span><br><span class="hljs-function"></span>&#123;<br>    uv *= ScanlineScale;<br><br>    uv.y += View.RealTime * ScanlineSpeed;<br><br>    <span class="hljs-type">float</span> scanline = ScanLineTexture.<span class="hljs-built_in">SampleLevel</span>(GlobalBilinearWrappedSampler,uv,<span class="hljs-number">0</span>).r;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0f</span> - scanline * ScanlineIntensity;<br>&#125;<br><br><br>[<span class="hljs-built_in">numthreads</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainCS</span><span class="hljs-params">(uint2 DispatchThreadId : SV_DispatchThreadID)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">any</span>(DispatchThreadId &gt;= SceneColorViewport_ViewportSize)) <span class="hljs-keyword">return</span>;<br><br>    float2 sampleUV = (<span class="hljs-built_in">float2</span>(SceneColorViewport_ViewportMin) + (<span class="hljs-built_in">float2</span>(DispatchThreadId) + <span class="hljs-number">0.5f</span>)) * SceneColorViewport_ExtentInverse;<br>    float2 screenCoord = sampleUV * <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.0f</span>;<br>    screenCoord *= RetroScaleFactor;<br><br>    <span class="hljs-type">float</span> viewAspect = (<span class="hljs-type">float</span>)SceneColorViewport_ViewportSize.x / (<span class="hljs-type">float</span>)SceneColorViewport_ViewportSize.y;<br>    <br>    float2 distortedUV = <span class="hljs-built_in">CalculateDistortedUV</span>(screenCoord, viewAspect);<br><br>    float4 distortedColor = <span class="hljs-built_in">CalculateDistortedColor</span>(distortedUV, viewAspect);<br>    <span class="hljs-type">float</span> luminance = <span class="hljs-built_in">CalcaulateLuminance</span>(distortedColor.rgb);<br>    float4 grain = <span class="hljs-built_in">CalculateColorGrain</span>(luminance, distortedUV * SceneColorViewport_ViewportSize);<br><br>    <span class="hljs-type">float</span> vignette = <span class="hljs-built_in">CalculateVignette</span>(distortedUV);<br>    <span class="hljs-type">float</span> scanline = <span class="hljs-built_in">CalculateScanline</span>(sampleUV);<br>    float4 tvMaskColor = TVMaskTexture.<span class="hljs-built_in">SampleLevel</span>(GlobalBilinearClampedSampler, sampleUV, <span class="hljs-number">0</span>);<br><br>    Output[SceneColorViewport_ViewportMin + DispatchThreadId] = (distortedColor + grain) * tvMaskColor * vignette * scanline;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>暂且不讨论具体的着色器实现逻辑，可以注意到我们在着色器中定义了多种不同类型的全局变量，例如 <code>Texture2D</code>、<code>float</code> 以及 <code>RWTexture2D&lt;float4&gt;</code>。这些变量在 <strong>C++ 侧有着各自不同的声明和绑定方式</strong>，需要分别进行处理。</p><p>除了自定义变量之外，我们还使用了一些 Unreal Engine 中已经预先声明好的内建变量。其中之一是<br><code>SCREEN_PASS_TEXTURE_VIEWPORT(SceneColorViewport)</code>，该宏能够为我们提供与当前视口尺寸相关的一系列参数，因此需要引入头文件 <code>ScreenPass.ush</code>。<br>另一个常用的内建变量是 <code>View</code>，它包含了大量与视图相关的运行时数据，例如本文着色器中用到的 <code>View.RealTime</code>。</p><h3 id="创建自定义SceneViewExtension"><a href="#创建自定义SceneViewExtension" class="headerlink" title="创建自定义SceneViewExtension"></a>创建自定义SceneViewExtension</h3><h4 id="自定义SVE类的-h文件声明"><a href="#自定义SVE类的-h文件声明" class="headerlink" title="自定义SVE类的.h文件声明"></a>自定义SVE类的.h文件声明</h4><p>接下来就可以基于自定义着色器来编写对应的 <code>SceneViewExtension</code> 了。首先新建一个名为 <code>RetroTVSceneViewExtension</code> 的 C++ 类，并继承自 <code>FSceneViewExtensionBase</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RETROTV_API</span> FRetroTVSceneViewExtension : <span class="hljs-keyword">public</span> FSceneViewExtensionBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FRetroTVSceneViewExtension</span>(<span class="hljs-type">const</span> FAutoRegister&amp; AutoRegister);<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetTVMaskTexture</span><span class="hljs-params">(<span class="hljs-type">const</span> UTexture2D* InTexture)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetScanLineTexture</span><span class="hljs-params">(<span class="hljs-type">const</span> UTexture2D* InTexture)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SubscribeToPostProcessingPass</span><span class="hljs-params">(EPostProcessingPass PassId, <span class="hljs-type">const</span> FSceneView&amp; View, FAfterPassCallbackDelegateArray&amp; InOutPassCallbacks, <span class="hljs-type">bool</span> bIsPassEnabled)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-function">FScreenPassTexture <span class="hljs-title">CustomPostProcessing</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">const</span> FSceneView&amp; View, <span class="hljs-type">const</span> FPostProcessMaterialInputs&amp; Inputs)</span></span>;<br><br><br><span class="hljs-keyword">private</span>:<br>FTextureRHIRef TVMaskTextureRHI;<br>FTextureRHIRef ScanLineTextureRHI;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个 SVE 类中，我们可以通过重写诸如<br><code>SetupViewFamily(FSceneViewFamily&amp; InViewFamily)</code>、<br><code>BeginRenderViewFamily(FSceneViewFamily&amp; InViewFamily)</code><br>等函数来修改视口属性，或在渲染流程中注入自定义 Pass。</p><p>不过，由于本文实现的是一个<strong>后处理效果</strong>，并不需要介入更早的渲染阶段，因此只需重写<br><code>SubscribeToPostProcessingPass( EPostProcessingPass PassId, const FSceneView&amp; View, FAfterPassCallbackDelegateArray&amp; InOutPassCallbacks, bool bIsPassEnabled )</code><br>这一函数即可。该函数的主要作用是将我们自定义的后处理流程（以函数的形式）注册为某个后处理阶段的回调，并在对应的渲染阶段自动被调用，也就是代码中的<code>CustomPostProcessing(FRDGBuilder&amp; GraphBuilder, const FSceneView&amp; View, const FPostProcessMaterialInputs&amp; Inputs)</code>。回调函数的参数有严格的要求，不可随意更改。</p><p>此外，着色器中还使用了两个 <strong>RDG 之外的外部纹理资源</strong>，因此需要分别创建两个资源句柄 <code>TVMaskTextureRHI</code> 和 <code>ScanLineTextureRHI</code>，并正确配置它们对应的 <code>Set</code> 方法。</p><h4 id="自定义SVE的-cpp文件"><a href="#自定义SVE的-cpp文件" class="headerlink" title="自定义SVE的.cpp文件"></a>自定义SVE的.cpp文件</h4><h5 id="注册并编译着色器"><a href="#注册并编译着色器" class="headerlink" title="注册并编译着色器"></a>注册并编译着色器</h5><p>在<code>RetroTVSceneViewExtension.cpp</code>文件中，首先需要创建一个和<code>.usf</code>文件对应的计算着色器类，相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RETROTV_API</span> FLenDistortionCS : <span class="hljs-keyword">public</span> FGlobalShader<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DECLARE_GLOBAL_SHADER</span>(FLenDistortionCS);<br><span class="hljs-built_in">SHADER_USE_PARAMETER_STRUCT</span>(FLenDistortionCS, FGlobalShader);<br><br><span class="hljs-built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters, )<br><span class="hljs-built_in">SHADER_PARAMETER_STRUCT</span>(FScreenPassTextureViewportParameters, SceneColorViewport)<br><span class="hljs-built_in">SHADER_PARAMETER_STRUCT_REF</span>(FViewUniformShaderParameters, View)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, RetroScaleFactor)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, LensDistortionK1)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, LensDistortionK2)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, VignetteStart)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, VignetteEnd)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, VignettePower)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, VignetteIntensity)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, ScanlineSpeed)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, ScanlineIntensity)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, ScanlineScale)<br><span class="hljs-built_in">SHADER_PARAMETER_RDG_TEXTURE</span>(Texture2D, OriginalSceneColor)<br><span class="hljs-built_in">SHADER_PARAMETER_TEXTURE</span>(Texture2D, TVMaskTexture)<br><span class="hljs-built_in">SHADER_PARAMETER_TEXTURE</span>(Texture2D, ScanLineTexture)<br><span class="hljs-built_in">SHADER_PARAMETER_RDG_TEXTURE_UAV</span>(RWTexture2D&lt;float4&gt;, Output)<br><span class="hljs-built_in">END_SHADER_PARAMETER_STRUCT</span>()<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ShouldCompilePermutation</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">IsFeatureLevelSupported</span>(Parameters.Platform, ERHIFeatureLevel::SM5);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ModifyCompilationEnvironment</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment)</span></span><br><span class="hljs-function"></span>&#123;<br>OutEnvironment.<span class="hljs-built_in">SetDefine</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;THREADS_X&quot;</span>), <span class="hljs-number">8</span>);<br>OutEnvironment.<span class="hljs-built_in">SetDefine</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;THREADS_Y&quot;</span>), <span class="hljs-number">8</span>);<br>OutEnvironment.<span class="hljs-built_in">SetDefine</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;THREADS_Z&quot;</span>), <span class="hljs-number">1</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_GLOBAL_SHADER</span>(FLenDistortionCS, <span class="hljs-string">&quot;/Plugins/RetroTVShaders/LensDistortion.usf&quot;</span>, <span class="hljs-string">&quot;MainCS&quot;</span>, SF_Compute);<br></code></pre></td></tr></table></figure><p>我们通过 <code>BEGIN_SHADER_PARAMETER_STRUCT()</code> 显式声明该着色器所使用的所有全局变量。只有在这里正确地定义并绑定这些参数，才能确保 C++ 侧的数据被正确传递到着色器中：</p><ol><li><code>SHADER_PARAMETER</code>：用于声明基础类型参数，例如 <code>float</code>、<code>int</code>、<code>uint</code> 等常量数据；</li><li><code>SHADER_PARAMETER_RDG_TEXTURE</code>：用于声明 <strong>由 RDG 创建并管理的只读纹理资源</strong>，通常作为 Shader Resource View（SRV）使用；</li><li><code>SHADER_PARAMETER_RDG_TEXTURE</code>：用于声明 <strong>位于 RDG 之外、由 RHI 管理的只读纹理资源</strong>，常用于外部导入的纹理（如 <code>UTexture2D</code>）；</li><li><code>SHADER-PARAMETER_RDG_TEXTURE_UAV</code>：用于声明 <strong>由 RDG 创建并管理的可读写纹理资源</strong>，通常作为 Compute Shader 的输出目标（UAV）；</li><li><code>SHADER_PARAMETER_STRUCT</code>：用于内嵌一个 <strong>值拷贝形式的参数结构体</strong>，例如视口参数、常量打包参数等；</li><li><code>SHADER_PARAMETER_STRUCT_REF</code>：用于引用一个 <strong>由引擎统一维护的参数结构体</strong>，常见的例子是 <code>View</code>、<code>SceneTextures</code> 等；</li></ol><p>最后，通过调用 <code>IMPLEMENT_GLOBAL_SHADER()</code> 将该着色器注册到 Unreal Engine 中，确保其在启动或编译阶段被正确编译，并能够被引擎正常识别和使用。</p><h5 id="声明控制台变量"><a href="#声明控制台变量" class="headerlink" title="声明控制台变量"></a>声明控制台变量</h5><p>由于控制台变量本身具备良好的线程安全性，因此这里使用控制台变量来控制着色器中的相关参数。相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;int32&gt; <span class="hljs-title">CVarShaderOn</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Enable RetroTV SceneViewExtension \n&quot;</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot; 0: OFF;&quot;</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot; 1: ON.&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarScaleFactor</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.ScaleFactor&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">1.0f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update ScaleFactor \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarLenDistortionK1</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.LenDistortionK1&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.05f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update LenDistortionK1 \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarLenDistortionK2</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.LenDistortionK2&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.02f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update LenDistortionK2 \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarVignetteStart</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.VignetteStart&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.7f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update VignetteStart \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarVignetteEnd</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.VignetteEnd&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">1.0f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update VignetteEnd \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarVignettePower</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.VignettePower&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">2.0f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update VignettePower \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarVignetteIntensity</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.VignetteIntensity&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.7f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update VignetteIntensity \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarScanlineSpeed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.ScanlineSpeed&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.2f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update ScanlineSpeed \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarScanlineIntensity</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.ScanlineIntensity&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.7f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update ScanlineIntensity \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarScanlineScale</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.ScanlineScale&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">5.0f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update ScanlineScale \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="设置纹理资源"><a href="#设置纹理资源" class="headerlink" title="设置纹理资源"></a>设置纹理资源</h5><p>我们还需要设置两个外部纹理资源（由 RHI 维护的纹理资源），相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FRetroTVSceneViewExtension::SetTVMaskTexture</span><span class="hljs-params">(<span class="hljs-type">const</span> UTexture2D* InTexture)</span></span><br><span class="hljs-function"></span>&#123;<br>FTextureRHIRef NewRHI = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">if</span> (InTexture &amp;&amp; InTexture-&gt;<span class="hljs-built_in">GetResource</span>())<br>&#123;<br>NewRHI = InTexture-&gt;<span class="hljs-built_in">GetResource</span>()-&gt;TextureRHI;<br>&#125;<br><br><span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(RetroTV_SetExtraTexture)<br>(<br>[<span class="hljs-keyword">this</span>, NewRHI](FRHICommandListImmediate&amp; RHICmdList)<br>&#123;<br>TVMaskTextureRHI = NewRHI;<br>&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FRetroTVSceneViewExtension::SetScanLineTexture</span><span class="hljs-params">(<span class="hljs-type">const</span> UTexture2D* InTexture)</span></span><br><span class="hljs-function"></span>&#123;<br>FTextureRHIRef NewRHI = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">if</span> (InTexture &amp;&amp; InTexture-&gt;<span class="hljs-built_in">GetResource</span>())<br>&#123;<br>NewRHI = InTexture-&gt;<span class="hljs-built_in">GetResource</span>()-&gt;TextureRHI;<br>&#125;<br><br><span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(RetroTV_SetExtraTexture)<br>(<br>[<span class="hljs-keyword">this</span>, NewRHI](FRHICommandListImmediate&amp; RHICmdList)<br>&#123;<br>ScanLineTextureRHI = NewRHI;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于输入纹理最初位于<strong>游戏线程</strong>，而渲染相关资源只能在<strong>渲染线程</strong>上安全访问，因此需要借助 <code>ENQUEUE_RENDER_COMMAND</code> 将这些资源的引用安全地传递到渲染线程中进行处理。</p><h5 id="注册回调函数"><a href="#注册回调函数" class="headerlink" title="注册回调函数"></a>注册回调函数</h5><p>Unreal Engine 的后处理流程被划分为多个不同的阶段，具体的阶段名称可以在 <code>EPostProcessingPass</code> 枚举中查阅。一般情况下，将自定义后处理插入到 <strong>MotionBlur</strong> 阶段即可满足需求。<br>我在实际测试中，将 Pass 插入到其他阶段时，往往会遇到诸如黑屏等问题，因此这里选择使用相对稳定的 MotionBlur 阶段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FRetroTVSceneViewExtension::SubscribeToPostProcessingPass</span><span class="hljs-params">(EPostProcessingPass PassId, <span class="hljs-type">const</span> FSceneView&amp; View,</span></span><br><span class="hljs-params"><span class="hljs-function">FAfterPassCallbackDelegateArray&amp; InOutPassCallbacks, <span class="hljs-type">bool</span> bIsPassEnabled)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (PassId == EPostProcessingPass::MotionBlur)<br>&#123;<br>InOutPassCallbacks.<span class="hljs-built_in">Add</span>(FAfterPassCallbackDelegate::<span class="hljs-built_in">CreateRaw</span>(<span class="hljs-keyword">this</span>, &amp;FRetroTVSceneViewExtension::CustomPostProcessing));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="编写自定义的Pass"><a href="#编写自定义的Pass" class="headerlink" title="编写自定义的Pass"></a>编写自定义的Pass</h5><p>这一步的实现也相对简单，只需要将前面准备好的参数传递给着色器即可。由于使用的是计算管线，不需要配置图形管线中诸如顶点布局、渲染状态等相关参数，因此整体流程显得更加简洁明了。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FScreenPassTexture <span class="hljs-title">FRetroTVSceneViewExtension::CustomPostProcessing</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">const</span> FSceneView&amp; SceneView,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FPostProcessMaterialInputs&amp; Inputs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> FSceneViewFamily&amp; ViewFamily = *SceneView.Family;<br><br><span class="hljs-type">const</span> FScreenPassTexture&amp; SceneColor = FScreenPassTexture::<span class="hljs-built_in">CopyFromSlice</span>(GraphBuilder, Inputs.<span class="hljs-built_in">GetInput</span>(EPostProcessMaterialInput::SceneColor));<br><br><span class="hljs-keyword">if</span> (!SceneColor.<span class="hljs-built_in">IsValid</span>() || CVarShaderOn.<span class="hljs-built_in">GetValueOnRenderThread</span>() == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> SceneColor;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> FScreenPassTextureViewport <span class="hljs-title">SceneColorViewport</span><span class="hljs-params">(SceneColor)</span></span>;<br><br><span class="hljs-built_in">RDG_EVENT_SCOPE</span>(GraphBuilder, <span class="hljs-string">&quot;RetroTV Postprocess Effect&quot;</span>);<br>&#123;<br>FGlobalShaderMap* GlobalShaderMap = <span class="hljs-built_in">GetGlobalShaderMap</span>(ViewFamily.<span class="hljs-built_in">GetFeatureLevel</span>());<br><span class="hljs-function">TShaderMapRef&lt;FLenDistortionCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GlobalShaderMap)</span></span>;<br><br>FRDGTextureDesc OutputDesc;<br>&#123;<br>OutputDesc = SceneColor.Texture-&gt;Desc;<br><span class="hljs-comment">// OutputDesc.Reset();</span><br>OutputDesc.Flags |= TexCreate_UAV;<br>OutputDesc.Flags &amp;= ~(TexCreate_RenderTargetable | TexCreate_FastVRAM);<br><br><span class="hljs-function">FLinearColor <span class="hljs-title">ClearColor</span><span class="hljs-params">(<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>)</span></span>;<br>OutputDesc.ClearValue = <span class="hljs-built_in">FClearValueBinding</span>(ClearColor);<br>&#125;<br><br>FRDGTextureRef OutputTexture = GraphBuilder.<span class="hljs-built_in">CreateTexture</span>(OutputDesc, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;LenDistortion Effect Output Texture&quot;</span>));<br><br>FLenDistortionCS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FLenDistortionCS::FParameters&gt;();<br><br>FIntPoint PassViewSize = SceneColor.ViewRect.<span class="hljs-built_in">Size</span>();<br><br>PassParameters-&gt;View = SceneView.ViewUniformBuffer;<br>PassParameters-&gt;RetroScaleFactor = CVarScaleFactor.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;LensDistortionK1 = CVarLenDistortionK<span class="hljs-number">1.</span><span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;LensDistortionK2 = CVarLenDistortionK<span class="hljs-number">2.</span><span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;VignetteStart = CVarVignetteStart.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;VignetteEnd = CVarVignetteEnd.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;VignettePower = CVarVignettePower.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;VignetteIntensity = CVarVignetteIntensity.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;ScanlineScale = CVarScanlineScale.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;ScanlineSpeed = CVarScanlineSpeed.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;ScanlineIntensity = CVarScanlineIntensity.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;OriginalSceneColor = SceneColor.Texture;<br>PassParameters-&gt;TVMaskTexture = TVMaskTextureRHI.<span class="hljs-built_in">IsValid</span>() ? TVMaskTextureRHI : GWhiteTexture-&gt;TextureRHI;<br>PassParameters-&gt;ScanLineTexture = ScanLineTextureRHI.<span class="hljs-built_in">IsValid</span>()? ScanLineTextureRHI : GWhiteTexture-&gt;TextureRHI;<br>PassParameters-&gt;SceneColorViewport = <span class="hljs-built_in">GetScreenPassTextureViewportParameters</span>(SceneColorViewport);<br>PassParameters-&gt;Output = GraphBuilder.<span class="hljs-built_in">CreateUAV</span>(<span class="hljs-built_in">FRDGTextureUAVDesc</span>(OutputTexture));<br><br>FIntVector GroupCount = FComputeShaderUtils::<span class="hljs-built_in">GetGroupCount</span>(PassViewSize, FComputeShaderUtils::kGolden2DGroupSize);<br><br>FComputeShaderUtils::<span class="hljs-built_in">AddPass</span>(<br>GraphBuilder,<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;LenDistorted Post Processing CS Shader %dx%d&quot;</span>, PassViewSize.X, PassViewSize.Y),<br>ComputeShader,<br>PassParameters,<br>GroupCount<br>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">FScreenPassTexture</span>(OutputTexture, SceneColor.ViewRect);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>值得一提的是，我们需要额外创建一张<strong>用于写入的输出纹理</strong>，而不能直接对输入的 <code>SceneColor</code> 进行 UAV 写入。最方便的做法是以 <code>SceneColor.Texture-&gt;Desc</code> 为基础复制一份描述信息，保证分辨率、格式等属性一致；随后再对其做少量修改：为其添加 <code>TexCreate_UAV</code> 标志，使其可被 Compute Shader 写入，同时移除 <code>TexCreate_RenderTargetable</code> 和 <code>TexCreate_FastVRAM</code> 等与当前使用场景不匹配的标志，并设置合适的清除色。</p><p>最后返回这个新建的输出纹理即可，它会由RDG自动管理。</p><h3 id="用DeveloperSettings获取外部纹理"><a href="#用DeveloperSettings获取外部纹理" class="headerlink" title="用DeveloperSettings获取外部纹理"></a>用DeveloperSettings获取外部纹理</h3><p>至此，我们已经创建了一个自定义的 <code>SceneViewExtension</code>。但由于 <code>SceneViewExtension</code> 并不是 <code>UObject</code> 的子类，无法在 Unreal Editor 中直接创建蓝图或暴露可编辑属性，那么该如何将 <strong>编辑器中配置的纹理资源</strong> 传递给这个 SVE 呢？</p><p>一个相对简单且常用的解决方案是借助 <code>DeveloperSettings</code> 类来维护这些全局资源。通过这种方式，我们可以在 <strong>项目设置（Project Settings）</strong> 的对应页面中直接指定所需的纹理或参数，而 <code>SceneViewExtension</code> 则在运行时读取这些配置并加以使用。</p><p>因此，新建一个C++类，父类选择<code>DeveloperSettings</code>，并在类中声明两个<code>UTexture2D</code>变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UTexture2D</span>;<br><br><span class="hljs-built_in">UCLASS</span>(Config = RetroTV, DefaultConfig, meta=(DisplayName=<span class="hljs-string">&quot;RetroTV&quot;</span>))<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RETROTV_API</span> URetroTVSettings : <span class="hljs-keyword">public</span> UDeveloperSettings<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, Config, Category = <span class="hljs-string">&quot;Textures&quot;</span>)<br>TSoftObjectPtr&lt;UTexture2D&gt; TVMaskTexture;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, Config, Category = <span class="hljs-string">&quot;Textures&quot;</span>)<br>TSoftObjectPtr&lt;UTexture2D&gt; ScanLineTexture;<br><br><span class="hljs-built_in">URetroTVSettings</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>现在打开UE的项目设置，找到RetroTV标签，打开之后就能指定资源了。</p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/IMG-20260131211529221.png" class=""><h3 id="实例化自定义SVE类"><a href="#实例化自定义SVE类" class="headerlink" title="实例化自定义SVE类"></a>实例化自定义SVE类</h3><p>在<code>Subsystem</code>中实例化SVE类是比较推荐的做法。因此新建一个C++类，命名为<code>RetroTVSubsystem</code>，父类选择<code>UGameInstanceSubsystem</code>。<br>它需要维护一个SVE类，并在这个子系统初始化的时候，用<code>UTexture2D</code>初始化SVE类中纹理资源。相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RETROTV_API</span> URetroTVSubsystem : <span class="hljs-keyword">public</span> UGameInstanceSubsystem<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(FSubsystemCollectionBase&amp; Collection)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Deinitialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>TSharedPtr&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">FRetroTVSceneViewExtension</span>, ESPMode::ThreadSafe&gt; CustomSceneViewExtension;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>对应函数实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RetroTVSubsystem.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RetroTVSettings.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RetroTVSceneViewExtension.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">URetroTVSubsystem::Initialize</span><span class="hljs-params">(FSubsystemCollectionBase&amp; Collection)</span></span><br><span class="hljs-function"></span>&#123;<br>CustomSceneViewExtension = FSceneViewExtensions::<span class="hljs-built_in">NewExtension</span>&lt;FRetroTVSceneViewExtension&gt;();<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;SceneViewExtensionTemplate: Subsystem initialized &amp; SceneViewExtension created&quot;</span>));<br><br><span class="hljs-type">const</span> URetroTVSettings* Settings = <span class="hljs-built_in">GetDefault</span>&lt;URetroTVSettings&gt;();<br>UTexture2D* TVMaskTexturePtr = Settings ? Settings-&gt;TVMaskTexture.<span class="hljs-built_in">LoadSynchronous</span>() : <span class="hljs-literal">nullptr</span>;<br>UTexture2D* ScanLineTexturePtr = Settings ? Settings-&gt;ScanLineTexture.<span class="hljs-built_in">LoadSynchronous</span>() : <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">if</span> (!TVMaskTexturePtr)<br>&#123;<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Warning, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;RetroTV: TVMaskTexture not set or failed to load. (Project Settings -&gt; RetroTV)&quot;</span>));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!ScanLineTexturePtr)<br>&#123;<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Warning, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;RetroTV: ScanLineTexture not set or failed to load. (Project Settings -&gt; RetroTV)&quot;</span>));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>CustomSceneViewExtension-&gt;<span class="hljs-built_in">SetTVMaskTexture</span>(TVMaskTexturePtr);<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;RetroTV: TVMaskTexture set to %s&quot;</span>), *TVMaskTexturePtr-&gt;<span class="hljs-built_in">GetName</span>());<br><br>CustomSceneViewExtension-&gt;<span class="hljs-built_in">SetScanLineTexture</span>(ScanLineTexturePtr);<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;RetroTV: ScanLineTexture set to %s&quot;</span>), *ScanLineTexturePtr-&gt;<span class="hljs-built_in">GetName</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">URetroTVSubsystem::Deinitialize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#123;<br>CustomSceneViewExtension-&gt;IsActiveThisFrameFunctions.<span class="hljs-built_in">Empty</span>();<br><br>FSceneViewExtensionIsActiveFunctor IsActiveFunctor;<br><br>IsActiveFunctor.IsActiveFunction = [](<span class="hljs-type">const</span> ISceneViewExtension* SceneViewExtension, <span class="hljs-type">const</span> FSceneViewExtensionContext&amp; Context)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">TOptional</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-literal">false</span>);<br>&#125;;<br><br>CustomSceneViewExtension-&gt;IsActiveThisFrameFunctions.<span class="hljs-built_in">Add</span>(IsActiveFunctor);<br>&#125;<br><br>CustomSceneViewExtension.<span class="hljs-built_in">Reset</span>();<br>CustomSceneViewExtension = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此所有代码编辑完成。</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>点击模拟（第一次模拟可能会出现问题，大概率是因为资源还没有完全加载完毕），在控制台输入<code>r.RetroTV 1</code>即可启用这个后处理效果：</p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/IMG-20260131212439161.png" class="">]]></content>
    
    
    <categories>
      
      <category>虚幻引擎</category>
      
      <category>渲染依赖图</category>
      
      <category>SceneViewExtension</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
      <tag>渲染依赖图</tag>
      
      <tag>RDG</tag>
      
      <tag>SceneViewExtension</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚幻引擎RDG图形管线调用流程</title>
    <link href="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是我在学习 Unreal 渲染依赖图（RDG）过程中的踩坑与总结笔记（二），本篇主要记录在虚幻引擎中调用图形管线的实践过程。</p><p>虚幻版本5.7</p><p>本篇主要介绍如何通过 <code>AddPass()</code> 调用图形管线，Unreal 引擎的配置与上一篇相同。</p><h3 id="在-UE-中使用-RDG-构建图形管线"><a href="#在-UE-中使用-RDG-构建图形管线" class="headerlink" title="在 UE 中使用 RDG 构建图形管线"></a>在 UE 中使用 RDG 构建图形管线</h3><h4 id="编写顶点和像素着色器的usf文件"><a href="#编写顶点和像素着色器的usf文件" class="headerlink" title="编写顶点和像素着色器的usf文件"></a>编写顶点和像素着色器的usf文件</h4><p>在工程目录下的<code>Shaders</code>创建一个名为<code>GraphicsShader.usf</code>的文件，编写以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Public/Platform.ush&quot;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VS_INPUT</span><br>&#123;<br>    float2 Position : ATTRIBUTE0;<br>    float2 TexCoord : ATTRIBUTE1;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VS_OUTPUT</span><br>&#123;<br>    float4 Position : SV_POSITION;<br>    float2 TexCoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainVS</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    in VS_INPUT Input,</span></span><br><span class="hljs-params"><span class="hljs-function">    out VS_OUTPUT Output</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>    Output.Position = <span class="hljs-built_in">float4</span>(Input.Position, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    Output.TexCoord = Input.TexCoord;<br>&#125;<br><br><span class="hljs-type">float</span> BValue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainPS</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    in VS_OUTPUT PS_Input,</span></span><br><span class="hljs-params"><span class="hljs-function">    out float4 OutColor : SV_Target0</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>    OutColor = <span class="hljs-built_in">float4</span>(PS_Input.TexCoord.x, PS_Input.TexCoord.y, BValue, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>.usf</code> 文件中，顶点输入必须通过 <code>ATTRIBUTE</code> 语义与顶点缓冲进行绑定。除系统语义外，着色器阶段之间只能使用 <code>TEXCOORD</code> 和 <code>COLOR</code> 作为中间语义。</p><h4 id="创建顶点和像素着色器的Global-Shader"><a href="#创建顶点和像素着色器的Global-Shader" class="headerlink" title="创建顶点和像素着色器的Global Shader"></a>创建顶点和像素着色器的Global Shader</h4><p>接下来我们将回到上一篇中的 <code>LearnRDGShader.cpp</code>，在此基础上继续完善代码。</p><p>在<code>LearnRDGShader.cpp</code>中添加以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> FTestVS : <span class="hljs-keyword">public</span> FGlobalShader<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DECLARE_GLOBAL_SHADER</span>(FTestVS);<br><span class="hljs-built_in">SHADER_USE_PARAMETER_STRUCT</span>(FTestVS, FGlobalShader);<br><br><span class="hljs-built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters, )<br><br><span class="hljs-built_in">END_SHADER_PARAMETER_STRUCT</span>()<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ShouldCompilePermutation</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_GLOBAL_SHADER</span>(FTestVS, <span class="hljs-string">&quot;/MyShaders/GraphicsShader.usf&quot;</span>, <span class="hljs-string">&quot;MainVS&quot;</span>, SF_Vertex);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> FTestPS : <span class="hljs-keyword">public</span> FGlobalShader<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DECLARE_GLOBAL_SHADER</span>(FTestPS);<br><span class="hljs-built_in">SHADER_USE_PARAMETER_STRUCT</span>(FTestPS, FGlobalShader);<br><br><span class="hljs-built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters,)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, BValue)<br><span class="hljs-built_in">RENDER_TARGET_BINDING_SLOTS</span>()<br><span class="hljs-built_in">END_SHADER_PARAMETER_STRUCT</span>()<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ShouldCompilePermutation</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_GLOBAL_SHADER</span>(FTestPS, <span class="hljs-string">&quot;/MyShaders/GraphicsShader.usf&quot;</span>, <span class="hljs-string">&quot;MainPS&quot;</span>, SF_Pixel);<br></code></pre></td></tr></table></figure><p>这段代码的作用是将 <code>.usf</code> 文件中定义的着色器注册为 Unreal 引擎可识别和使用的全局着色器。</p><h4 id="使用FRDGBuilder添加计算Pass"><a href="#使用FRDGBuilder添加计算Pass" class="headerlink" title="使用FRDGBuilder添加计算Pass"></a>使用FRDGBuilder添加计算Pass</h4><p>在<code>LearnRDGShader.h</code>中添加函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> LearnRDGShader<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTestGraphicsPass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, FRDGTextureRef RenderTarget, <span class="hljs-type">float</span> BValue)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的 <code>FRDGTextureRef</code> 作为我们的渲染目标使用，本质上是一块存放在显存中的纹理缓冲区。</p><p>在<code>LearnRDGShader.cpp</code>中实现函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LearnRDGShader::AddTestGraphicsPass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, FRDGTextureRef RenderTarget, <span class="hljs-type">float</span> BValue)</span></span><br><span class="hljs-function"></span>&#123;<br>FGlobalShaderMap* ShaderMap =  <span class="hljs-built_in">GetGlobalShaderMap</span>(GMaxRHIFeatureLevel);<br><br><span class="hljs-function">TShaderMapRef&lt;FTestVS&gt; <span class="hljs-title">VertexShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><span class="hljs-function">TShaderMapRef&lt;FTestPS&gt; <span class="hljs-title">PixelShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><br>FTestPS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestPS::FParameters&gt;();<br>PassParameters-&gt;BValue = BValue;<br>PassParameters-&gt;RenderTargets[<span class="hljs-number">0</span>] = <span class="hljs-built_in">FRenderTargetBinding</span>(RenderTarget, ERenderTargetLoadAction::EClear);<br><br>GraphBuilder.<span class="hljs-built_in">AddPass</span>(<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;MyTestGraphicsPass&quot;</span>),<br>PassParameters,<br>ERDGPassFlags::Raster,<br>[\*Todo*\](FRHICommandList&amp; RHICmdList)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>和计算着色器相比，图形管线的配置会麻烦不少。我们需要依次配置图形管线的各个部分，比如顶点缓冲区、全局缓冲区，以及图形管线本身的各种选项。</p><p>接下来我们先来配置顶点缓冲区，整体流程可以分为以下几个步骤：</p><ol><li>在 GPU 侧创建顶点缓冲区；</li><li>在 CPU 侧声明并准备具体的顶点数据；</li><li>将 CPU 端的数据上传到刚刚创建的 GPU 顶点缓冲区中；</li><li>配置对应的 <code>FVertexDeclarationRHIRef</code>；</li><li>将其绑定到 <code>FGraphicsPipelineStateInitializer</code> 的 <code>BoundShaderState.VertexDeclarationRHI</code> 中；</li><li>指定所需的缓冲区。</li></ol><p>相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LearnRDGShader::AddTestGraphicsPass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, FRDGTextureRef RenderTarget, <span class="hljs-type">float</span> BValue)</span></span><br><span class="hljs-function"></span>&#123;<br>FGlobalShaderMap* ShaderMap =  <span class="hljs-built_in">GetGlobalShaderMap</span>(GMaxRHIFeatureLevel);<br><br><span class="hljs-function">TShaderMapRef&lt;FTestVS&gt; <span class="hljs-title">VertexShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><span class="hljs-function">TShaderMapRef&lt;FTestPS&gt; <span class="hljs-title">PixelShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><br>FTestPS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestPS::FParameters&gt;();<br>PassParameters-&gt;BValue = BValue;<br>PassParameters-&gt;RenderTargets[<span class="hljs-number">0</span>] = <span class="hljs-built_in">FRenderTargetBinding</span>(RenderTarget, ERenderTargetLoadAction::EClear);<br><br><span class="hljs-comment">//Start Edit</span><br><span class="hljs-keyword">constexpr</span> uint32 NumVertices = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">constexpr</span> uint32 NumIndices = <span class="hljs-number">6</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VS_INPUT</span><br>&#123;<br>FVector2f Position;<br>FVector2f TexCoord;<br>&#125;;<br><br>FRDGBufferRef VertexBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateUploadDesc</span>(<span class="hljs-built_in">sizeof</span>(VS_INPUT), NumVertices),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyVertexBuffer&quot;</span>));<br><br><span class="hljs-function">FRDGUploadData&lt;VS_INPUT&gt; <span class="hljs-title">VSInputData</span><span class="hljs-params">(GraphBuilder, <span class="hljs-number">4</span>)</span></span>;<br>VSInputData[<span class="hljs-number">0</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">-1.0f</span>,  <span class="hljs-number">1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">1</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>,  <span class="hljs-number">1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">2</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">3</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>) &#125;;<br><br>GraphBuilder.<span class="hljs-built_in">QueueBufferUpload</span>(VertexBuffer, VSInputData, ERDGInitialDataFlags::NoCopy);<br><br>FRDGBufferRef IndexBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateUploadDesc</span>(<span class="hljs-built_in">sizeof</span>(uint32), NumIndices),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyIndexBuffer&quot;</span>));<br><br><span class="hljs-function">FRDGUploadData&lt;int32&gt; <span class="hljs-title">Indices</span><span class="hljs-params">(GraphBuilder, <span class="hljs-number">6</span>)</span></span>;<br>Indices[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>Indices[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>Indices[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>Indices[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>Indices[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>;<br>Indices[<span class="hljs-number">5</span>] = <span class="hljs-number">3</span>;<br><br>GraphBuilder.<span class="hljs-built_in">QueueBufferUpload</span>(IndexBuffer, Indices, ERDGInitialDataFlags::NoCopy);<br><br>uint16 Stride = <span class="hljs-built_in">sizeof</span>(VS_INPUT);<br>FVertexDeclarationElementList Elements;<br>Elements.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">FVertexElement</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">STRUCT_OFFSET</span>(VS_INPUT, Position), VET_Float2, <span class="hljs-number">0</span>, Stride));<br>Elements.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">FVertexElement</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">STRUCT_OFFSET</span>(VS_INPUT, TexCoord), VET_Float2, <span class="hljs-number">1</span>, Stride));<br>FVertexDeclarationRHIRef VertexDeclarationRHI = PipelineStateCache::<span class="hljs-built_in">GetOrCreateVertexDeclaration</span>(Elements);<br><br><span class="hljs-comment">//End Edit</span><br><br>GraphBuilder.<span class="hljs-built_in">AddPass</span>(<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;MyTestGraphicsPass&quot;</span>),<br>PassParameters,<br>ERDGPassFlags::Raster,<br>[VertexDeclarationRHI](FRHICommandList&amp; RHICmdList)<br>&#123;<br><span class="hljs-comment">//Start Edit</span><br>FGraphicsPipelineStateInitializer GraphicsPSOInit;<br>GraphicsPSOInit.BoundShaderState.VertexShaderRHI = VertexShader.<span class="hljs-built_in">GetVertexShader</span>();<br><span class="hljs-built_in">SetGraphicsPipelineState</span>(RHICmdList, GraphicsPSOInit, <span class="hljs-number">0</span>);<br><br>RHICmdList.<span class="hljs-built_in">SetStreamSource</span>(<span class="hljs-number">0</span>, VertexBuffer-&gt;<span class="hljs-built_in">GetRHI</span>(), <span class="hljs-number">0</span>);<br>RHICmdList.<span class="hljs-built_in">DrawIndexedPrimitive</span>(IndexBuffer-&gt;<span class="hljs-built_in">GetRHI</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//End Edit</span><br>&#125;<br>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们通过 <code>FRDGBuilder</code> 的成员函数 <code>CreateBuffer()</code> 来创建缓冲区，随后调用 <code>QueueBufferUpload()</code> 将 CPU 端的数据上传到顶点缓冲区中。</p><p>索引缓冲区的处理方式与此相同，按照同样的流程进行创建和数据上传即可。</p><p>配置管线的各种选项，包括视口大小、深度模板测试、混合方式、剔除方式、图元类型等等，完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LearnRDGShader::AddTestGraphicsPass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, FRDGTextureRef RenderTarget, <span class="hljs-type">float</span> BValue)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">constexpr</span> uint32 NumVertices = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">constexpr</span> uint32 NumIndices = <span class="hljs-number">6</span>;<br><span class="hljs-function"><span class="hljs-type">const</span> FIntRect <span class="hljs-title">ViewRect</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, RenderTarget-&gt;Desc.Extent.X, RenderTarget-&gt;Desc.Extent.Y)</span></span>;<br><br><br>FGlobalShaderMap* ShaderMap =  <span class="hljs-built_in">GetGlobalShaderMap</span>(GMaxRHIFeatureLevel);<br><br><span class="hljs-function">TShaderMapRef&lt;FTestVS&gt; <span class="hljs-title">VertexShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><span class="hljs-function">TShaderMapRef&lt;FTestPS&gt; <span class="hljs-title">PixelShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VS_INPUT</span><br>&#123;<br>FVector2f Position;<br>FVector2f TexCoord;<br>&#125;;<br><br>FRDGBufferRef VertexBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateUploadDesc</span>(<span class="hljs-built_in">sizeof</span>(VS_INPUT), NumVertices),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyVertexBuffer&quot;</span>));<br><br><span class="hljs-function">FRDGUploadData&lt;VS_INPUT&gt; <span class="hljs-title">VSInputData</span><span class="hljs-params">(GraphBuilder, <span class="hljs-number">4</span>)</span></span>;<br>VSInputData[<span class="hljs-number">0</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">-1.0f</span>,  <span class="hljs-number">1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">1</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>,  <span class="hljs-number">1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">2</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">3</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>) &#125;;<br><br>GraphBuilder.<span class="hljs-built_in">QueueBufferUpload</span>(VertexBuffer, VSInputData, ERDGInitialDataFlags::NoCopy);<br><br>FRDGBufferRef IndexBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateUploadDesc</span>(<span class="hljs-built_in">sizeof</span>(uint32), NumIndices),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyIndexBuffer&quot;</span>));<br><br><span class="hljs-function">FRDGUploadData&lt;int32&gt; <span class="hljs-title">Indices</span><span class="hljs-params">(GraphBuilder, <span class="hljs-number">6</span>)</span></span>;<br>Indices[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>Indices[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>Indices[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>Indices[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>Indices[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>;<br>Indices[<span class="hljs-number">5</span>] = <span class="hljs-number">3</span>;<br><br>GraphBuilder.<span class="hljs-built_in">QueueBufferUpload</span>(IndexBuffer, Indices, ERDGInitialDataFlags::NoCopy);<br><br>FTestPS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestPS::FParameters&gt;();<br>PassParameters-&gt;BValue = BValue;<br>PassParameters-&gt;RenderTargets[<span class="hljs-number">0</span>] = <span class="hljs-built_in">FRenderTargetBinding</span>(RenderTarget, ERenderTargetLoadAction::EClear);<br><br>uint16 Stride = <span class="hljs-built_in">sizeof</span>(VS_INPUT);<br>FVertexDeclarationElementList Elements;<br>Elements.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">FVertexElement</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">STRUCT_OFFSET</span>(VS_INPUT, Position), VET_Float2, <span class="hljs-number">0</span>, Stride));<br>Elements.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">FVertexElement</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">STRUCT_OFFSET</span>(VS_INPUT, TexCoord), VET_Float2, <span class="hljs-number">1</span>, Stride));<br>FVertexDeclarationRHIRef VertexDeclarationRHI = PipelineStateCache::<span class="hljs-built_in">GetOrCreateVertexDeclaration</span>(Elements);<br><br>GraphBuilder.<span class="hljs-built_in">AddPass</span>(<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;MyTestGraphicsPass&quot;</span>),<br>PassParameters,<br>ERDGPassFlags::Raster,<br>[VertexShader, PixelShader, PassParameters, VertexBuffer, IndexBuffer, ViewRect, VertexDeclarationRHI](FRHICommandList&amp; RHICmdList)<br>&#123;<br>RHICmdList.<span class="hljs-built_in">SetViewport</span>(ViewRect.Min.X, ViewRect.Min.Y, <span class="hljs-number">0.0f</span>, ViewRect.Max.X, ViewRect.Max.Y, <span class="hljs-number">1.0f</span>);<br><br>FGraphicsPipelineStateInitializer GraphicsPSOInit;<br>RHICmdList.<span class="hljs-built_in">ApplyCachedRenderTargets</span>(GraphicsPSOInit);<br>GraphicsPSOInit.BlendState = TStaticBlendState&lt;&gt;::<span class="hljs-built_in">GetRHI</span>();<br>GraphicsPSOInit.RasterizerState = TStaticRasterizerState&lt;&gt;::<span class="hljs-built_in">GetRHI</span>();<br>GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState&lt;<span class="hljs-literal">false</span>, CF_Always&gt;::<span class="hljs-built_in">GetRHI</span>();<br>GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = VertexDeclarationRHI;<br>GraphicsPSOInit.BoundShaderState.VertexShaderRHI = VertexShader.<span class="hljs-built_in">GetVertexShader</span>();<br>GraphicsPSOInit.BoundShaderState.PixelShaderRHI = PixelShader.<span class="hljs-built_in">GetPixelShader</span>();<br>GraphicsPSOInit.PrimitiveType = PT_TriangleList;<br><span class="hljs-built_in">SetGraphicsPipelineState</span>(RHICmdList, GraphicsPSOInit, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">SetShaderParameters</span>(RHICmdList, PixelShader, PixelShader.<span class="hljs-built_in">GetPixelShader</span>(), *PassParameters);<br><br>RHICmdList.<span class="hljs-built_in">SetStreamSource</span>(<span class="hljs-number">0</span>, VertexBuffer-&gt;<span class="hljs-built_in">GetRHI</span>(), <span class="hljs-number">0</span>);<br><br>RHICmdList.<span class="hljs-built_in">DrawIndexedPrimitive</span>(IndexBuffer-&gt;<span class="hljs-built_in">GetRHI</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>&#125;<br>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在Actor中的BeginPlay-中调用"><a href="#在Actor中的BeginPlay-中调用" class="headerlink" title="在Actor中的BeginPlay()中调用"></a>在Actor中的BeginPlay()中调用</h3><p>新建一个 C++ 类，父类选择 <code>Actor</code>，并命名为 <code>GraphicsRDGHelper</code>。<br>随后在 <code>GraphicsRDGHelper</code> 类的 <code>BeginPlay()</code> 生命周期函数中，调用前面实现的用于向 RDG 添加计算 Pass 的函数。</p><p><code>GraphicsRDGHelper.h</code>的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GraphicsRDGHelper.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> AGraphicsRDGHelper : <span class="hljs-keyword">public</span> AActor<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Sets default values for this actor&#x27;s properties</span><br><span class="hljs-built_in">AGraphicsRDGHelper</span>();<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="hljs-string">&quot;TestShader&quot;</span>)<br>TObjectPtr&lt;UTextureRenderTarget2D&gt; GraphicsRDGRenderTarget;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="hljs-string">&quot;TestShader&quot;</span>)<br><span class="hljs-type">float</span> BValue = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Called every frame</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTestGraphicsPass</span><span class="hljs-params">(UTextureRenderTarget2D* RenderTarget2D, <span class="hljs-type">float</span> BChannelValue)</span> <span class="hljs-type">const</span></span>;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><code>GraphicsRDGHelper.cpp</code>的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GraphicsRDGHelper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphBuilder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Engine/TextureRenderTarget2D.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LearnRDGShader.h&quot;</span></span><br><span class="hljs-comment">// Sets default values</span><br>AGraphicsRDGHelper::<span class="hljs-built_in">AGraphicsRDGHelper</span>()<br>&#123;<br> <span class="hljs-comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span><br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AGraphicsRDGHelper::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">BeginPlay</span>();<br><br><span class="hljs-built_in">check</span>(GEngine != <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsValid</span>(GraphicsRDGRenderTarget))<br><span class="hljs-built_in">AddTestGraphicsPass</span>(GraphicsRDGRenderTarget.<span class="hljs-built_in">Get</span>(), BValue);<br>&#125;<br><br><span class="hljs-comment">// Called every frame</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AGraphicsRDGHelper::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">Tick</span>(DeltaTime);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AGraphicsRDGHelper::AddTestGraphicsPass</span><span class="hljs-params">(UTextureRenderTarget2D* RenderTarget2D, <span class="hljs-type">float</span> BChannelValue)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AddTestGraphicsPass&quot;</span>));<br><br>FTextureResource* RenderResource = RenderTarget2D-&gt;<span class="hljs-built_in">GetResource</span>();<br><br><span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(AddTestGraphicsPass)(<br>[RenderResource, BChannelValue](FRHICommandListImmediate&amp; RHICmdList)<br>&#123;<br>FRDGBuilder <span class="hljs-built_in">GraphBuilder</span>(RHICmdList);<br><br>FTextureRHIRef TextureRHI = RenderResource-&gt;<span class="hljs-built_in">GetTextureRHI</span>();<br><br>FRDGTextureRef RDGTexture =<br>GraphBuilder.<span class="hljs-built_in">RegisterExternalTexture</span>(<br><span class="hljs-built_in">CreateRenderTarget</span>(TextureRHI, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyRT2D_External&quot;</span>))<br>);<br><br>LearnRDGShader::<span class="hljs-built_in">AddTestGraphicsPass</span>(GraphBuilder, RDGTexture, BChannelValue);<br><br>GraphBuilder.<span class="hljs-built_in">Execute</span>();<br>&#125;<br>);<br><br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AddTestGraphicsPassFinish&quot;</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="在编辑器中创建蓝图"><a href="#在编辑器中创建蓝图" class="headerlink" title="在编辑器中创建蓝图"></a>在编辑器中创建蓝图</h3><p>接下来为刚刚编写的 C++ 类创建对应的 UE 蓝图，并新建一个 <code>Material</code> 和一个 <code>RenderTarget</code>。将该 <code>RenderTarget</code> 连接到 <code>Material</code> 的 Base Color（基础色）输入上，然后将该 <code>Material</code> 指定给对应的 UE 蓝图进行使用。</p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260127165041585.png" class=""><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260127165144256.png" class=""><p>点击模拟，可以看到颜色已经正确地输入到纹理</p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260127165226753.png" class=""><h3 id="AddFullScreenPass"><a href="#AddFullScreenPass" class="headerlink" title="AddFullScreenPass"></a>AddFullScreenPass</h3><p>对于仅包含全屏两个三角形的顶点数据，可以直接使用 Unreal 提供的 <code>AddFullScreenPass</code> 辅助函数来简化代码实现，具体用法可以参考 UE 的相关源码实现。需要注意的是，在使用该辅助函数时，像素着色器在通常情况下只能接收一个 <code>float4</code> 类型的“位置”输入。</p><p>一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Public/Platform.ush&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Private/Common.ush&quot;</span></span><br><br><span class="hljs-type">float</span> BValue;<br>float2 TargetSize;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FullscreenPS</span><span class="hljs-params">(float4 InPosition : SV_POSITION,  out float4 OutColor : SV_Target0)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 UV = InPosition.xy / TargetSize;<br>    OutColor = <span class="hljs-built_in">float4</span>(UV.x, UV.y, BValue, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，与 GLSL 中的用法不同，这里的 <code>SV_POSITION</code> 表示的是屏幕空间下的像素位置，而非归一化后的 <code>[-1, 1]</code> NDC 坐标。</p>]]></content>
    
    
    <categories>
      
      <category>虚幻引擎</category>
      
      <category>渲染依赖图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
      <tag>渲染依赖图</tag>
      
      <tag>RDG</tag>
      
      <tag>图形管线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚幻引擎RDG计算管线调用流程</title>
    <link href="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是我在学习 Unreal 渲染依赖图（RDG）过程中的踩坑与总结笔记（一），本篇主要记录在虚幻引擎中调用计算着色器的实践过程。</p><p>Unreal版本为5.7。</p><h3 id="配置Unreal工程"><a href="#配置Unreal工程" class="headerlink" title="配置Unreal工程"></a>配置Unreal工程</h3><h4 id="创建Unreal工程"><a href="#创建Unreal工程" class="headerlink" title="创建Unreal工程"></a>创建Unreal工程</h4><p>创建一个空白C++虚幻工程，将项目名称设置为<code>LearnRDG</code>。</p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260124194958682.png" class=""><h4 id="配置uproject"><a href="#配置uproject" class="headerlink" title="配置uproject"></a>配置uproject</h4><p>打开工程文件夹下的<code>LearnRDG.uproject</code>，将<code>Modules</code>内的<code>LoadingPharse</code>从<code>Default</code>修改为<code>PostConfigInit</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-string">&quot;Modules&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;LearnRDG&quot;</span>,<br><span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br><span class="hljs-comment">// &quot;LoadingPharse&quot;: &quot;Default&quot;,</span><br><span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;PostConfigInit&quot;</span>,<br><span class="hljs-string">&quot;AdditionalDependencies&quot;</span>: [<br><span class="hljs-string">&quot;Engine&quot;</span><br>]<br>&#125;<br>]<br></code></pre></td></tr></table></figure><h4 id="修改LearnRDG-Build-cs"><a href="#修改LearnRDG-Build-cs" class="headerlink" title="修改LearnRDG.Build.cs"></a>修改LearnRDG.Build.cs</h4><p>打开<code>LearnRDG.Build.cs</code>，添加<code>RHI</code>、<code>RenderCore</code>、<code>Projects</code>依赖。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LearnRDG</span> : <span class="hljs-title">ModuleRules</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LearnRDG</span>(<span class="hljs-params">ReadOnlyTargetRules Target</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">Target</span>)</span><br>&#123;<br>PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br><br>PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>,                          <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span> &#125;);<br><br>PrivateDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;RHI&quot;</span>,                          <span class="hljs-string">&quot;RenderCore&quot;</span>, <span class="hljs-string">&quot;Projects&quot;</span> &#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改LearnRDG-cpp"><a href="#修改LearnRDG-cpp" class="headerlink" title="修改LearnRDG.cpp"></a>修改LearnRDG.cpp</h4><p>官方文档中提到，Unreal 的着色器文件（<code>.usf</code> &#x2F; <code>.ush</code>）通常存放在 <code>Engine/Shaders</code> 和 <code>Engine/Plugins</code> 目录下。</p><p>为了便于管理，我们希望将自定义着色器放置在工程目录中，因此首先在工程根目录下创建一个 <code>Shaders</code> 文件夹。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LearnRDG<br>|- Content<br>|- Sources<br>|- Shaders <span class="hljs-comment">// Shaders文件夹和Content|Sources处于同一目录下</span><br></code></pre></td></tr></table></figure><p>随后打开<code>LearnRDG.cpp</code>文件，将内容替换为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LearnRDG.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Modules/ModuleManager.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Misc/Paths.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ShaderCore.h&quot;</span> </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FLearnRDGGameModule</span> : <span class="hljs-keyword">public</span> FDefaultGameModuleImpl<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">StartupModule</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> FString ShaderDir = FPaths::<span class="hljs-built_in">Combine</span>(FPaths::<span class="hljs-built_in">ProjectDir</span>(), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Shaders&quot;</span>));<br><span class="hljs-built_in">AddShaderSourceDirectoryMapping</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/MyShaders&quot;</span>), ShaderDir);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShutdownModule</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_PRIMARY_GAME_MODULE</span>(FLearnRDGGameModule, LearnRDG, <span class="hljs-string">&quot;LearnRDG&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>在 <code>FLearnRDGGameModule</code> 的 <code>StartupModule()</code> 中，通过相关代码构建虚拟路径映射。完成映射后，即可使用 <strong><code>/MyShaders</code></strong> 来指代工程目录下的 <strong><code>/Shaders</code></strong> 文件夹，从而像使用引擎内置着色器路径一样引用自定义着色器。</p><p><strong>关闭虚幻编辑器，编译Visual Studio工程。</strong><br>一定要关闭编辑器后再编译，不然会遇到许多莫名其妙的问题（后续每次编译都需要先关闭虚幻编译器）。</p><h3 id="在-UE-中使用-RDG-构建计算管线"><a href="#在-UE-中使用-RDG-构建计算管线" class="headerlink" title="在 UE 中使用 RDG 构建计算管线"></a>在 UE 中使用 RDG 构建计算管线</h3><h4 id="编写计算着色器的usf文件"><a href="#编写计算着色器的usf文件" class="headerlink" title="编写计算着色器的usf文件"></a>编写计算着色器的usf文件</h4><p>在工程目录下的<code>Shaders</code>创建一个名为<code>ComputeShader.usf</code>的文件，编写以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Public/Platform.ush&quot;</span></span><br><br><span class="hljs-type">float</span> Scale;<br><span class="hljs-type">float</span> Translate;<br>  <br>StructuredBuffer&lt;<span class="hljs-type">float</span>&gt; InputBuffer;<br>RWStructuredBuffer&lt;<span class="hljs-type">float</span>&gt; OutputBuffer;<br><br>[<span class="hljs-built_in">numthreads</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainCS</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    uint3 DispatchThreadId : SV_DispatchThreadID,</span></span><br><span class="hljs-params"><span class="hljs-function">    uint GroupIndex : SV_GroupIndex)</span></span><br><span class="hljs-function"></span>&#123;<br>    OutputBuffer[DispatchThreadId.x] = InputBuffer[DispatchThreadId.x] * Scale + Translate;<br>&#125;<br></code></pre></td></tr></table></figure><p>（示例计算着色器来自：<a href="https://sirenri2001.github.io/2025-02-05-unreal-shader-tutorial-(Chinese)/">Unreal Shader Tutorial - Chinese Ver. | SirEnri’s Homepage</a>）</p><h4 id="创建计算着色器的Global-Shader"><a href="#创建计算着色器的Global-Shader" class="headerlink" title="创建计算着色器的Global Shader"></a>创建计算着色器的Global Shader</h4><p>打开UE编辑器，选择 工具-&gt;新建C++文件，父类选择 <strong>无</strong>，命名为<code>LearnRDGShader</code>。</p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260124203441757.png" class=""><p>删除<code>LearnRDGShader.h</code>中<code>#include &quot;CoreMinimal.h&quot;</code>以下的所有代码，删除<code>LearnRDGShader.cpp</code>中的所有代码。</p><p>在<code>LearnRDGShader.cpp</code>中编写以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LearnRDGShader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GlobalShader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphBuilder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ShaderParameterStruct.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphDefinitions.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphUtils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RHIGPUReadback.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ScreenPass.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PixelShaderUtils.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> FTestCS : <span class="hljs-keyword">public</span> FGlobalShader<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DECLARE_GLOBAL_SHADER</span>(FTestCS);<br><span class="hljs-built_in">SHADER_USE_PARAMETER_STRUCT</span>(FTestCS, FGlobalShader);<br><br><span class="hljs-built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters, )<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, Scale)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, Translate)<br><span class="hljs-built_in">SHADER_PARAMETER_RDG_BUFFER_SRV</span>(StructuredBuffer&lt;<span class="hljs-type">float</span>&gt;, InputBuffer)<br><span class="hljs-built_in">SHADER_PARAMETER_RDG_BUFFER_UAV</span>(RWStructuredBuffer&lt;<span class="hljs-type">float</span>&gt;, OutputBuffer)<br><span class="hljs-built_in">END_SHADER_PARAMETER_STRUCT</span>()<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ShouldCompilePermutation</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_GLOBAL_SHADER</span>(FTestCS, <span class="hljs-string">&quot;/MyShaders/ComputeShader.usf&quot;</span>, <span class="hljs-string">&quot;MainCS&quot;</span>, SF_Compute);<br></code></pre></td></tr></table></figure><p>着色器类的声明参考UE源码，<code>BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )</code>内部的宏定义需要与<strong>HLSL源文件中的着色器输入</strong>一一对应。</p><p>随后调用<code>IMPLEMENT_GLOBAL_SHADER</code>，把 <code>.usf</code> 里的计算着色器入口函数，注册成 Unreal 可识别、可编译、可使用的全局着色器类型。</p><p>EPIC官方文档：<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/render-dependency-graph-in-unreal-engine">虚幻引擎中的渲染依赖图 | 虚幻引擎 5.7 文档 | Epic Developer Community</a></p><h4 id="使用-FRDGBuilder-添加计算-Pass"><a href="#使用-FRDGBuilder-添加计算-Pass" class="headerlink" title="使用 FRDGBuilder 添加计算 Pass"></a>使用 FRDGBuilder 添加计算 Pass</h4><p>在<code>LearnRDGShader.h</code>添加函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> LearnRDGShader<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span> </span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>FRDGBuilder</code>是UE的RDG构建器，可以通过这个构建在渲染图中添加计算通道。<code>Scale</code>和<code>Translate</code>用于配置<code>Hlsl</code>中的参数。<code>FRHIGPUBufferReadback</code>用于回读计算着色器的输出结果到CPU。</p><p>在<code>LearnRDGShader.cpp</code>中实现函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>首先获取之前注册的计算着色器:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Start Edit</span><br><span class="hljs-function">TShaderMapRef&lt;FTestCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GetGlobalShaderMap(GMaxRHIFeatureLevel))</span></span>;<br><span class="hljs-comment">//End Edit</span><br>&#125;<br></code></pre></td></tr></table></figure><p>随后需要配置计算着色器的参数，包括两个 <code>float</code> 类型的标量参数、一个作为输入的 <code>SRV</code> 缓冲区，以及一个作为输出的 <code>UAV</code> 缓冲区。</p><p>这些参数通过 <code>FTestCS::FParameters</code> 结构体进行描述，并在创建 Pass 时将对应的资源与数值绑定到该结构体实例上。</p><p>现在配置<code>float</code>类型的标量参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">TShaderMapRef&lt;FTestCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GetGlobalShaderMap(GMaxRHIFeatureLevel))</span></span>;<br><span class="hljs-comment">//Start Edit</span><br>FTestCS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestCS::FParameters&gt;();<br>PassParameters-&gt;Scale = Scale;<br>PassParameters-&gt;Translate = Translate;<br><span class="hljs-comment">//End Edit</span><br>&#125;<br></code></pre></td></tr></table></figure><p>配置缓冲区稍微复杂，参考UE官方文档和源码，配置步骤如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">TShaderMapRef&lt;FTestCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GetGlobalShaderMap(GMaxRHIFeatureLevel))</span></span>;<br><br>FTestCS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestCS::FParameters&gt;();<br>PassParameters-&gt;Scale = Scale;<br>PassParameters-&gt;Translate = Translate;<br><br><span class="hljs-comment">//Start Edit</span><br><span class="hljs-keyword">constexpr</span> uint32 BufferElementNum = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">constexpr</span> uint32 BufferSize = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * BufferElementNum;<br><br>TArray&lt;<span class="hljs-type">float</span>&gt; InitialData; <span class="hljs-comment">//随便创建一些初始数据</span><br>InitialData.<span class="hljs-built_in">Init</span>(<span class="hljs-number">10.0f</span>, BufferElementNum);<br><br>FRDGBufferRef InRDGBuffer = <span class="hljs-built_in">CreateStructuredBuffer</span>(<br>GraphBuilder, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;TestCS.InRDGBuffer&quot;</span>), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), BufferElementNum,<br>InitialData.<span class="hljs-built_in">GetData</span>(), BufferSize<br>);<br><br>FRDGBufferSRVRef InSRV = GraphBuilder.<span class="hljs-built_in">CreateSRV</span>(InRDGBuffer);<br><br>FRDGBufferRef OutRDGBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateStructuredDesc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), BufferElementNum),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;TestCS.OutRDGBuffer&quot;</span>)<br>);<br>FRDGBufferUAVRef OutUAV = GraphBuilder.<span class="hljs-built_in">CreateUAV</span>(OutRDGBuffer);<br><br>PassParameters-&gt;InputBuffer = InSRV;<br>PassParameters-&gt;OutputBuffer = OutUAV;<br><span class="hljs-comment">//End Edit</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于需要在创建计算 Pass 之前从 CPU 侧初始化 GPU 缓冲区数据，这里使用 UE 提供的辅助函数 <code>CreateStructuredBuffer</code> 来创建输入缓冲区 <code>InRDGBuffer</code>。该函数会负责创建 RDG Buffer，并将初始数据上传至 GPU。</p><p>对于输出缓冲区，由于不需要 CPU 侧提供初始数据，直接通过 <code>FRDGBuilder</code> 的成员函数 <code>CreateBuffer</code> 创建即可（实际上，<code>CreateStructuredBuffer</code> 的内部实现同样是基于 <code>CreateBuffer</code> 创建临时缓冲区）。</p><p>需要注意的是，在创建 <code>FRDGBufferRef</code> 之后，还需要分别创建对应的 <code>FRDGBufferSRVRef</code> 和 <code>FRDGBufferUAVRef</code> 才能在着色器中进行访问。这一设计与 Vulkan 中 <code>VkBuffer</code> 和 <code>VkBufferView</code> 的关系类似：前者表示资源本体，后者则描述了资源的具体访问方式。</p><p>随后添加计算Pass并回读数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">TShaderMapRef&lt;FTestCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GetGlobalShaderMap(GMaxRHIFeatureLevel))</span></span>;<br><br>FTestCS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestCS::FParameters&gt;();<br>PassParameters-&gt;Scale = Scale;<br>PassParameters-&gt;Translate = Translate;<br><br><span class="hljs-keyword">constexpr</span> uint32 BufferElementNum = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">constexpr</span> uint32 BufferSize = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * BufferElementNum;<br><br>TArray&lt;<span class="hljs-type">float</span>&gt; InitialData; <span class="hljs-comment">//随便创建一些初始数据</span><br>InitialData.<span class="hljs-built_in">Init</span>(<span class="hljs-number">10.0f</span>, BufferElementNum);<br><br>FRDGBufferRef InRDGBuffer = <span class="hljs-built_in">CreateStructuredBuffer</span>(<br>GraphBuilder, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;TestCS.InRDGBuffer&quot;</span>), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), BufferElementNum,<br>InitialData.<span class="hljs-built_in">GetData</span>(), BufferSize<br>);<br><br>FRDGBufferSRVRef InSRV = GraphBuilder.<span class="hljs-built_in">CreateSRV</span>(InRDGBuffer);<br><br>FRDGBufferRef OutRDGBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateStructuredDesc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), BufferElementNum),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;TestCS.OutRDGBuffer&quot;</span>)<br>);<br>FRDGBufferUAVRef OutUAV = GraphBuilder.<span class="hljs-built_in">CreateUAV</span>(OutRDGBuffer);<br><br>PassParameters-&gt;InputBuffer = InSRV;<br>PassParameters-&gt;OutputBuffer = OutUAV;<br><span class="hljs-comment">//Start Edit</span><br>GraphBuilder.<span class="hljs-built_in">AddPass</span>(<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;MyAddCS&quot;</span>),<br>PassParameters,<br>ERDGPassFlags::Compute,<br>[PassParameters, ComputeShader, OutRDGBuffer, Readback](FRHICommandList&amp; RHICmdList)<br>&#123;<br>FComputeShaderUtils::<span class="hljs-built_in">Dispatch</span>(RHICmdList, ComputeShader, *PassParameters, <span class="hljs-built_in">FIntVector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>&#125;<br>);<br><br><span class="hljs-built_in">AddEnqueueCopyPass</span>(GraphBuilder, Readback, OutRDGBuffer, BufferSize);<br><span class="hljs-comment">//End Edit</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>FRDGBuilder</code> 的成员函数 <code>AddPass</code> 向 Render Graph 中添加一个计算 Pass，并在传入的 lambda 函数中定义该 Pass 的执行逻辑。</p><p>从使用方式上看，这一过程与 Vulkan 中通过 <code>vkCmd</code> 系列函数向命令缓冲区提交操作较为相似，</p><p>最后，通过 UE 提供的辅助函数 <code>AddEnqueueCopyPass</code> 将计算结果回读到 CPU。需要注意的是，数据回读必须通过单独的 Pass 来完成，而不能直接在前面计算 Pass 的 lambda 函数中进行。</p><p>这是因为在 RDG 的构建阶段，Pass 仅用于描述执行逻辑，此时相关计算 Pass 可能尚未执行完成，资源依赖和状态尚未满足；只有通过额外的拷贝 Pass，才能确保在计算结果生成之后再进行数据回读。</p><h3 id="在-Actor-的-BeginPlay-中调用"><a href="#在-Actor-的-BeginPlay-中调用" class="headerlink" title="在 Actor 的 BeginPlay() 中调用"></a>在 Actor 的 BeginPlay() 中调用</h3><p>新建一个 C++ 类，父类选择 <code>Actor</code>，并命名为 <code>ComputeRDGHelper</code>。<br>随后在 <code>ComputeRDGHelper</code> 类的 <code>BeginPlay()</code> 生命周期函数中，调用前面实现的用于向 RDG 添加计算 Pass 的函数。</p><p><code>ComputeRDGHelper.h</code>的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RHIGPUReadback.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ComputeRDGHelper.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> AComputeRDGHelper : <span class="hljs-keyword">public</span> AActor<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Sets default values for this actor&#x27;s properties</span><br><span class="hljs-built_in">AComputeRDGHelper</span>();<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="hljs-string">&quot;TestShader&quot;</span>)<br><span class="hljs-type">float</span> ScaleValue = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="hljs-string">&quot;TestShader&quot;</span>)<br><span class="hljs-type">float</span> TranslateValue = <span class="hljs-number">2.0f</span>;<br><br>TSharedPtr&lt;FRHIGPUBufferReadback, ESPMode::ThreadSafe&gt; Readback;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Called every frame</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTestComputePass</span><span class="hljs-params">(<span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><code>ComputeRDGHelper.cpp</code>的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ComputeRDGHelper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphBuilder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LeranRDGShader.h&quot;</span></span><br><br><span class="hljs-comment">// Sets default values</span><br>AComputeRDGHelper::<span class="hljs-built_in">AComputeRDGHelper</span>()<br>&#123;<br> <span class="hljs-comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span><br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AComputeRDGHelper::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">BeginPlay</span>();<br><br><span class="hljs-built_in">check</span>(GEngine != <span class="hljs-literal">nullptr</span>);<br><br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;BeginPlay()!&quot;</span>));<br><br>Readback = <span class="hljs-built_in">MakeShared</span>&lt;FRHIGPUBufferReadback&gt;(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyAddReadback&quot;</span>));<br><br><span class="hljs-built_in">AddTestComputePass</span>(ScaleValue, TranslateValue);<br>&#125;<br><br><span class="hljs-comment">// Called every frame</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AComputeRDGHelper::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">Tick</span>(DeltaTime);<br><br>    <span class="hljs-keyword">if</span> (!Readback.<span class="hljs-built_in">IsValid</span>())<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (!Readback-&gt;<span class="hljs-built_in">IsReady</span>())<br>        <span class="hljs-keyword">return</span>;<br><br>    TSharedPtr&lt;FRHIGPUBufferReadback, ESPMode::ThreadSafe&gt; Local = Readback;<br>    Readback.<span class="hljs-built_in">Reset</span>();<br><br>    <span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(PollReadback)(<br>        [Local](FRHICommandListImmediate&amp; RHICmdList)<br>        &#123;<br>            <span class="hljs-type">const</span> uint32 NumBytes = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">2</span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">void</span>* DataPtr = Local-&gt;<span class="hljs-built_in">Lock</span>(NumBytes);<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span>* Values = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">float</span>*&gt;(DataPtr);<br><br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> A = Values[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> B = Values[<span class="hljs-number">1</span>];<br><br>            Local-&gt;<span class="hljs-built_in">Unlock</span>();<br><br>            <span class="hljs-built_in">AsyncTask</span>(ENamedThreads::GameThread, [A, B]()<br>                &#123;<br>                    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Readback: %f %f&quot;</span>), A, B);<br>                &#125;);<br>        &#125;<br>        );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AComputeRDGHelper::AddTestComputePass</span><span class="hljs-params">(<span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AddTestComputePass&quot;</span>));<br><br><span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(AddComputePass)(<br>[Scale, Translate, ReadbackPtr = Readback.<span class="hljs-built_in">Get</span>()](FRHICommandListImmediate&amp; RHICmdList)<br>&#123;<br>FRDGBuilder <span class="hljs-built_in">GraphBuilder</span>(RHICmdList);<br><br>TestShader::<span class="hljs-built_in">AddTestComputePass</span>(GraphBuilder, Scale, Translate, ReadbackPtr);<br><br>GraphBuilder.<span class="hljs-built_in">Execute</span>();<br>&#125;<br>);<br><br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AddTestComputePassFinish&quot;</span>));<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>与 RDG 相关的操作必须在<strong>渲染线程Render Thread</strong>中执行，如果在<strong>游戏线程Game Thread</strong>中直接调用，将导致程序崩溃。因此需要使用 <code>ENQUEUE_RENDER_COMMAND()</code> 将相关逻辑封装并提交到渲染线程执行。</p><h3 id="在编辑器中创建蓝图"><a href="#在编辑器中创建蓝图" class="headerlink" title="在编辑器中创建蓝图"></a>在编辑器中创建蓝图</h3><p>为刚刚编写的 C++ 类创建对应的 UE 蓝图，将其拖入场景中并点击 <strong>Simulate</strong> 进行运行。</p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260124214249038.png" class=""><p>随后查看输出目录，可以发现计算结果已成功从 GPU 回读到 CPU。</p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260124214329509.png" class="">]]></content>
    
    
    <categories>
      
      <category>虚幻引擎</category>
      
      <category>渲染依赖图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
      <tag>渲染依赖图</tag>
      
      <tag>RDG</tag>
      
      <tag>计算着色器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Marschner毛发模型</title>
    <link href="/2025/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/02-Marschner%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/02-Marschner%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><em><strong>论文：Light Scattering from Human Hair Fibers, SIGGRAPH 2003</strong></em><br>参考资料：<a href="https://gaukler.github.io/2023/10/21/study-notes-on-the-marschner-hair-shading-model.html">Study Notes On The Marschner Hair Shading Model | Blog</a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>一个 Fiber（纤维，毛发）的由三个层次组成：</p><ol><li>cuticle：角质层，位于毛发最外层，看起来像多个圆锥面重叠在一起；</li><li>cortex：皮质层，毛发内部的主要部分；</li><li>medulla：髓质层，毛发中心部分。</li></ol><p>Marschner模型只考虑了cuticle和cortex两部分，并用折射率$\eta$和吸收系数（an absorption cross section）$\sigma_a$描述毛发内部的属性。</p><h3 id="模型概览"><a href="#模型概览" class="headerlink" title="模型概览"></a>模型概览</h3><p>Marschner模型的示意图如下：</p><img src="/2025/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/02-Marschner%E6%A8%A1%E5%9E%8B/IMG-20260110151649582.png" class=""><p><strong>Marschner 模型的着色由三种主要成分构成：R、TT 与 TRT：</strong></p><ol><li><strong>R（Reflection）</strong>：光线入射到毛发表面后直接发生镜面反射，形成表面反射分量。</li><li><strong>TT（Transmission-Transmission）</strong>：光线入射时先折射进入毛发内部，再在另一侧折射出纤维，从而形成透射分量。</li><li><strong>TRT（Transmission-Reflection-Transmission）</strong>：光线入射时折射进入毛发内部，在纤维另一侧发生一次反射，随后再折射回原侧射出，形成内部反射分量。</li></ol><p><strong>假设入射光是白色：</strong><br><strong>R 分量</strong>代表光线在毛发表面发生的直接镜面反射，会在表面形成一块白色高光；而 <strong>TRT 分量</strong>则源于光线折射进入毛发内部后，在另一侧发生一次反射，再折射回原侧射出。由于光线在这一过程中会被毛发内部的 <strong>cortex</strong> 和 <strong>medulla</strong> 部分吸收，因此最终呈现为一块带有色彩的高光。</p><h3 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h3><p>为了描述光照打到毛发后的行为，Marschner模型定义了以下符号：</p><img src="/2025/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/02-Marschner%E6%A8%A1%E5%9E%8B/IMG-20260110151649611.png" class=""><p>下面将依次解释这些符号：</p><ol><li>$\boldsymbol u$：毛发的切线（轴线）方向，由发根（root）指向发梢（tip）；</li><li>$\boldsymbol v,\boldsymbol w$：毛发的法线方向，两者正交，张成的平面称为法平面$v-w$，且$v$为主轴。与$u$形成正交的坐标系‘</li><li>$(\boldsymbol{\omega}_{i}$：光照方向，也可以理解为入射光方向的反方向，用球面坐标表示；</li><li>$(\boldsymbol{\omega}_{r}$：散射方向（包括反射和折射），也用球面坐标表示；</li><li>$\theta_i,\theta_r$：光照方向和散射方向相对于法平面的倾角，$0^{\circ}$意味着处于法平面上，$90^{\circ}$与$u$的方向相同，$-90^{\circ}$与$u$的方向相反；</li><li>$\phi_i,\phi_r$：光照方向和散射方向的方位角，$0^{\circ}$意味着与$v$同向，$90^{\circ}$与$w$同向。</li></ol><p>除此之外还有一些根据这些定义导出的角度，用于简化后续的符号表示：</p><ol><li>$\theta_d$：倾角的偏差角$\frac{\theta_r-\theta_i}{2}$;</li><li>$\phi$：相对方位角$\phi_r-\phi_i$；</li><li>$\theta_h$：平均倾角$\frac{\theta_r+\theta_i}{2}$;</li><li>$\phi_h$：平均方位角$\frac{\phi_r+\phi_i}{2}$;</li></ol><h3 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h3><p><strong>基本辐射度量学</strong></p><p>辐射度量学广泛运用于真实感光照模型中，常用的符号与定义如下：</p><ol><li>$Q$：辐射能量（Radiant Energy），某个过程辐射出的总能量，记作焦耳$J$;</li><li>$\Phi$：辐射通量（Radiant Flux&#x2F;Power），辐射的总功率，即单位时间内的辐射总量，定义为$\Phi&#x3D;\frac{\mathrm{d} Q}{\mathrm{d} t}$，单位$W$或$J&#x2F;s$;</li><li>$I$：辐射强度（Radiant Intensity），单位立体角的辐射通量，定义为$I&#x3D;\frac{\mathrm d \Phi}{\mathrm d \omega}$，单位为$W&#x2F;sr$；</li><li>$E$：辐照度（Irradiance），单位<strong>投影</strong>面积$\mathrm d A_{\perp}$的辐射通量，定义为$E&#x3D;\frac{\mathrm d \Phi}{\mathrm d A }$，单位为$W&#x2F;m^2$；</li><li>$L$：辐射亮度（Radiance），单位立体角、单位<strong>投影</strong>面积$\mathrm d A \cos\theta$的辐射通量，定义为$L&#x3D;\frac{\mathrm d^2 \Phi}{\mathrm d \omega \mathrm d A \cos\theta}$，单位$W&#x2F;(sr\cdot m^2)$。</li></ol><p>根据定义不难发现，$Q$，$\Phi$，$I$不会随着距离的远近而发生改变。 $L$也是距离不变量，但相对不太直观：<br>注意到$L&#x3D;\frac{\mathrm d E}{\mathrm d \omega}$，由于单位面积为不变量，因此不会随着距离改变。当单位接收平面距离光源更远的时候，其与光源形成的立体角会变小，并且立体角与距离也满足$r^2$的比例关系。<br>#补图</p><p><strong>毛发辐射度量学</strong></p><p>与毛发相关的辐射度量学不同：对于毛发，我们关注的不是单位投影面积接收到的辐射通量，而是单位曲线长度（curve）接收到的辐射通量。这里的curve可以理解毛发横截面（近似圆柱体的横截面）上的单位弧长。<br>相关定义如下：</p><ol><li>$\bar{E}$：曲线辐照度（Curve Irradiance），单位弧长的辐射通量，$E&#x3D;\frac{\mathrm d \Phi}{\mathrm d l }$，单位$W&#x2F;m$；</li><li>$\bar{L}$：曲线辐射强度（Curve Intensity），单位弧长的辐照强度，即<strong>一条光线</strong>，定义为$L&#x3D;\frac{\mathrm d^2 \Phi}{\mathrm d \omega \mathrm d l \cos\theta}$，单位$W&#x2F;(sr\cdot m)$。</li></ol><p>类似于BRDF模型，它们之间满足散射函数$S$：$$S(\boldsymbol{\omega}<em>{i},\boldsymbol{\omega}</em>{r})&#x3D;\frac{\mathrm d \bar{L_r}(\boldsymbol{\omega}<em>{r})}{\mathrm d \bar{E_i}(\boldsymbol{\omega}</em>{i})}$$<br>$S$是一个方向分布函数，衡量了入射光在方向$\boldsymbol{\omega}<em>{i}$上被毛发散射到方向 $\boldsymbol{\omega}</em>{r}$的效率，即有多少光线被散射到了方向$\boldsymbol{\omega}<em>{r}$上。<br>我在这里把入射点理解为一个单位弧长的中继器，它会接受固定入射方向$\boldsymbol w_i$的辐射通量，即$\mathrm d \bar{E_i}(\boldsymbol{\omega}</em>{i})$，然后这个中继器会将接收到的辐射通量向各个方向重新分配并发射，对应某个方向就是$\mathrm d \bar{L_r}(\boldsymbol{\omega}_{r})$，它们的比值衡量了中继器在各个方向分配的辐射通量的概率密度分布。</p><p>Curve Irradiance和Curve Intensity成正比关系：$$d\bar{E}_i(\boldsymbol{\omega}_i)&#x3D;DL_i(\boldsymbol{\omega}_i)\cos\theta_id\boldsymbol{\omega}_i$$<br>其中$D$代表毛发横截面直径（如果是横截面是椭圆形，还与入射光线的方位角相关），因此$D\cos\theta_i$代表横截面在方向$\boldsymbol \omega_i$上的投影。这里的$D$是为了将辐照度（Irradiance）转化为曲线辐照度（Curve Irradiance）：在纤维上，一个无穷小长度的曲线$\mathrm dl$所对应的受光面积可以近似表示为$\mathrm A &#x3D; D \cdot \mathrm dl$。</p><p>根据定义，散射光的积分可以写成：<br>$$\bar{L}_r(\boldsymbol{\omega}_r)&#x3D;D\int S(\boldsymbol{\omega}_i,\boldsymbol{\omega}_r)L_i(\boldsymbol{\omega}_i)\cos\boldsymbol{\theta}_id\boldsymbol{\omega}_i$$</p><h3 id="一些有趣的实验现象"><a href="#一些有趣的实验现象" class="headerlink" title="一些有趣的实验现象"></a>一些有趣的实验现象</h3><p><strong>实验一：入射平面</strong><br>这里的入射平面指入射光和轴线所形成的二维平面。实验一就是在这个平面上测量不同波长的散射分布。</p><img src="/2025/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/02-Marschner%E6%A8%A1%E5%9E%8B/IMG-20260110151649633.png" class=""><p>注意到：</p><ol><li>人工合成的头发高光区域精准地分布在镜面反射方向附近，而真实的头发的高光区域会向着发根（root）偏转$6^{\circ}-10^{\circ}$。</li><li>在金发的入射平面实验中，注意到不同波长的光线散射的分布不一致，并且在<strong>镜面反射</strong>方向会出现一个次级的亮度峰值（次级高光）。而黑发则没有这样的现象。</li></ol><p><strong>实验二：法线平面</strong><br>法线平面实验指入射光处于法线平面的实验，测量对象是这个法线平面上各个方向散射光的亮度。</p><img src="/2025/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/02-Marschner%E6%A8%A1%E5%9E%8B/IMG-20260110151649660.png" class=""><p>注意到：</p><ol><li>在法平面上存在两个明显的峰值，该论文称之为闪光（glint）。</li><li>测量的结果随着$\phi_i$的旋转发生改变，但是关于$\phi_i$的$180^{\circ}$旋转对称。</li><li>出现了焦散。</li></ol><p>#TODO：焦散</p><p><strong>实验三：半球面</strong><br>半球面实验是对前两个实验的扩展，记录了不同角度关系下散射光的亮度，实验结论与前两个实验保持一致。</p><p><strong>实验结论</strong></p><ol><li>R是主要高光的形成原因，之所以主要高光会向发根偏移，使因为毛发表面角质层的倾斜造成的。</li><li>TT会让有颜色的头发在背光面也显得非常亮。</li><li>TRT是有颜色的次级高光的形成的原因，它相较于主要高光会向发梢略微偏移，由于与主要高光很近，有时候表现为主要高光边缘处的彩色光圈。<br>次级高光的位置与$\phi$和$\theta$两者相关。当入射光线处于法线平面上时，会产生两个不同的glint，随着入射光线倾角的增加，两个glint会逐渐汇聚在入射平面上，形成一个更亮的glint，最终表现得和入射平面实验一样。</li></ol><h3 id="散射光线分布"><a href="#散射光线分布" class="headerlink" title="散射光线分布"></a>散射光线分布</h3><p>下面这张图时散射光线方向示意图，其中（a）为反射，（b）为折射。球中垂直于地面的直径是毛发的轴线方向，与其正交的大圆所在面即法平面（平行于地面）。$v_i$是入射光线，$v_r$是反射光线，$v_t$是折射光线。</p><img src="/2025/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/02-Marschner%E6%A8%A1%E5%9E%8B/IMG-20260110151649682.png" class=""><p>结论：</p><ol><li>根据反射定律，反射光线与法线的夹角和入射光线与法线的夹角相同，而法平面上的任何一个方向都是毛发的法向，因此$v_r$是一个集合，分布在一个圆锥上，且$v_r$和$v_i$的高度相同。</li><li>根据Snell定律，折射光线和入射光线满足$\eta\sin\theta_t&#x3D;\sin\theta_i$，同样的，由于法线是一个集合，因此$v_t$也是一个集合，分布在一个圆锥上，且$v_t$比$v_i$更加靠近法平面。</li></ol><h3 id="布拉维定律（Bravais’s-law"><a href="#布拉维定律（Bravais’s-law" class="headerlink" title="布拉维定律（Bravais’s law)"></a>布拉维定律（Bravais’s law)</h3><p>在光学和晶体学中，Bravais’s law指出：如果将入射光线和透射光线投影到包含表面法线的平面中，它们依然满足折射定律，但是需要一个修正之后的折射率。修正的折射率称为<strong>Bravais index</strong>，这里称为布维拉折射率。推导需要用到的示意图如下：</p><img src="/2025/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/02-Marschner%E6%A8%A1%E5%9E%8B/IMG-20260110151649710.png" class=""><p>示意图中，法平面平行于屏幕，毛发轴线垂直指向屏幕内（或相反）。 其中$v_i$和$v_t$分别为入射光线和透射光线，折射率为$\eta$；$v_i’$和$v_t’$分别为入射光线和投射光线分别在法平面上的投影，它们之间的布维拉折射率为$\eta’$。</p><p>原文中并没有给出具体的推导过程，并且存在一些错误，下面给出布维拉折射率的具体推导过程：<br>根据Snell定律$\eta\sin\theta_t&#x3D;\sin\theta_i$，容易得到$$\eta |s_t|&#x3D;|s_i|$$<br>由于投影在水平面上的三角形相似，得$$\eta |s_t’|&#x3D;|s_i’|$$<br>设$v_i$为单位向量，则$|v_i|&#x3D;1$，因此$\sin \theta_i’$可以表示为：$$\sin \theta_i’&#x3D;\frac{|s_i’|}{|v_i’|}$$<br>$v_i’$是$v_i$在垂直平面上的投影，因此模长满足：$$|v_i’|&#x3D;|v_i|\cos\gamma&#x3D;\cos\gamma$$<br>代回$\sin \theta_i’$的表达式：$$\sin \theta_i’&#x3D;\frac{|s_i’|}{\cos\gamma}$$<br>同样，$\sin \theta_t’$也满足：$$\sin \theta_t’&#x3D;\frac{|s_t’|}{\cos\delta}$$<br>投影平面的折射过程满足$\sin \theta_i’ &#x3D; \eta’\sin \theta_t’$，整理上式得到：$$\begin{align}\eta’<br>&amp;&#x3D;\frac{|s_i’|}{|s_t’|}\frac{cos\delta}{cos\gamma} \<br>&amp;&#x3D; \eta \frac{cos\delta}{cos\gamma}<br>\end{align}$$<br>再根据投影在水平面上的两个相似三角形，得到：$$<br>\begin{align}<br>|v_i|\sin\gamma&amp;&#x3D;\eta|v_t|\sin\delta \<br>\sin\gamma &amp;&#x3D;\eta\sin\delta<br>\end{align}$$<br>现在我们要做的就是将$\eta’$转化成关于$\gamma$的函数，消除$\delta$：<br>$$<br>\begin{align}<br>\eta’\cos\gamma &amp;&#x3D;\eta\cos\delta \<br>\eta’\cos\gamma &amp;&#x3D;\eta\sqrt{1-\sin^2{\delta}} \<br>\eta’\cos\gamma &amp;&#x3D; \eta\sqrt{1-\frac{\sin^2\gamma}{\eta^2}} \<br>\eta’\cos\gamma &amp;&#x3D; \sqrt{\eta^2-\sin^2\gamma}\<br>\end{align}<br>$$<br>最终我们得到了$\eta’$关于$\gamma$的函数：$$\eta’(\gamma)&#x3D;\frac{\sqrt{\eta^2-\sin^2\gamma}}{\eta^2}$$</p><h3 id="布拉维和斯涅尔（Bravais-and-Fresnel）"><a href="#布拉维和斯涅尔（Bravais-and-Fresnel）" class="headerlink" title="布拉维和斯涅尔（Bravais and Fresnel）"></a>布拉维和斯涅尔（Bravais and Fresnel）</h3><p>我们已经得到了投影在垂直平面上的有效折射率$\eta’$了，但是有效折射率并不能很好地估计Fresnel反射率。注意到入射向量和投影向量在$n$方向上的投影长度相同，有：<br>$$\cos\theta_i^{\prime}&#x3D;\cos\theta_i&#x2F;\cos\gamma$$<br>同理，对于透射向量有：$$\cos\theta_t^{\prime}&#x3D;\cos\theta_t&#x2F;\cos\delta.$$<br>对Fresnel反射率的计算公式进行变形，首先是S偏振光：<br>$$\begin{aligned}<br>F_{s} &amp;<br>\begin{aligned}<br>&#x3D;\frac{\cos\theta_i-\eta\cos\theta_t}{\cos\theta_i+\eta\cos\theta_t}<br>\end{aligned} \<br> &amp; &#x3D;\frac{\frac{\cos\theta_i}{\cos\gamma}-\eta\frac{\cos\delta}{\cos\gamma}\frac{\cos\theta_t}{\cos\delta}}{\frac{\cos\theta_i}{\cos\gamma}+\eta\frac{\cos\gamma}{\cos\gamma}\frac{\cos\theta_t}{\cos\delta}} \<br> &amp; &#x3D;\frac{\cos\theta_i^{\prime}-\eta^{\prime}\cos\theta_t^{\prime}}{\cos\theta_i^{\prime}+\eta^{\prime}\cos\theta_t^{\prime}}<br>\end{aligned}$$<br>同样变形P偏振光：<br>$$\begin{aligned}<br>F_{p} &amp;<br>\begin{aligned}<br>&#x3D;\frac{\eta\cos\theta_i-\cos\theta_t}{\eta\cos\theta_i+\cos\theta_t}<br>\end{aligned} \<br> &amp; &#x3D;\frac{\eta\frac{\cos\gamma}{\cos\delta}\frac{\cos\theta_{i}}{\cos\gamma}-\frac{\cos\theta_{t}}{\cos\delta}}{\eta\frac{\cos\gamma}{\cos\delta}\frac{\cos\theta_{i}}{\cos\gamma}+\frac{\cos\theta_{t}}{\cos\delta}} \<br> &amp; &#x3D;\frac{\eta^{\prime\prime}\cos\theta_i^{\prime}-\cos\theta_t^{\prime}}{\eta^{\prime\prime}\cos\theta_i^{\prime}+\cos\theta_t^{\prime}}<br>\end{aligned}$$<br>这里的$\eta’’$和有效折射率$\eta’$的推导方式一致：<br>$$\eta^{\prime\prime}&#x3D;\eta\frac{\cos\gamma}{\cos\delta}&#x3D;\frac{\eta^2\cos\gamma}{\sqrt{\eta^2-\sin^2\gamma}}$$<br>最终Fresnel可以表示成关于$\eta’,\eta’’,\gamma$的函数$F(\eta’,\eta’’,\gamma)$。</p><h3 id="毛发散射理论"><a href="#毛发散射理论" class="headerlink" title="毛发散射理论"></a>毛发散射理论</h3><p>回顾散射函数：<br>$$S(\boldsymbol{\omega}<em>{i},\boldsymbol{\omega}</em>{r})&#x3D;\frac{\mathrm d \bar{L_r}(\boldsymbol{\omega}<em>{r})}{\mathrm d \bar{E_i}(\boldsymbol{\omega}</em>{i})}$$<br>散射函数的输入有四个维度，分别是$\theta_i,\theta_t,\phi_i,\phi_t$。</p><p>Marschner模型是建立在圆柱体上的散射模型，它将4维散射方程分解成了两个2维项（$M$和$N$）的乘积。其中$M$刻画了对倾角$\theta$的依赖，$N$刻画了对方位角$\phi$的依赖。</p><p><strong>毛发的基本散射行为：</strong></p><ol><li>假设毛发表面光滑，且内部不会发生体积散射，那么以一定倾角$\theta_i$入射的光线，无论发生了多少次反射和折射，最终都会以倾角$\theta_r &#x3D; -\theta_i$射出。这意味着一束以相同倾角入射的光线，最终的出射光线会分布在一个圆锥面上；同样，毛发内部的光线也会分布在一个圆锥面上。<br>因此，在已知入射倾角$\theta_i$，毛发内部的光线和出射光线的倾角就确定下来了。四个维度的散射函数变成了三个维度。</li><li>既然已经知道了倾角$\theta_r$，那我们只需要计算方位角$\phi_r$即可，根据之前有效折射率（布维拉法则）的相关推导，我们可以将反射和折射投影到毛发的法平面进行关于$\phi_i,\phi_r$的二维分析。</li></ol><p><strong>毛发表面光滑</strong><br>当毛发表面光滑的时候，只会发生镜面反射：<br>$$S(\phi_i,\theta_i;\phi_r,\theta_r)&#x3D;\delta(\theta_r+\theta_i)N(\eta^{\prime}(\theta);\phi_i,\phi_r)&#x2F;\cos^2\theta$$<br>这里的$\delta$只有当$\theta_r+\theta_i&#x3D;0$的时候为1，其余情况都为0，描述了光线镜面反射的特性。$\cos\theta$为了将法平面的分布关系转换回3D空间中。<br>#TODO：如何合理解释为什么要除以cos</p><p><strong>毛发表面粗糙</strong><br>当毛发表面粗糙的时候，需要考虑微表面模型：<br>$$S(\phi_i,\theta_i;\phi_r,\theta_r)&#x3D;M(\theta_i,\theta_r)N(\eta^{\prime}(\theta_d);\phi_i,\phi_r)&#x2F;\cos^2\theta_d;$$<br>由于是粗糙表面，需要考虑入射光线在入射平面的散射函数，用$M$替换$\delta$。<br>此外需要考虑微表面模型。微表面模型使毛发的法线法线发生变化。<br>考虑入射光线和散射光线的倾角分别为$\theta_i,\theta_r$，我们可以认为散射点处的微表面的法向量就是$\theta_h$，而入射光线相对于$\theta_h$的倾角就是$\theta_d$。</p><h4 id="方位角散射函数（Azimuthal-Scattering-Function）"><a href="#方位角散射函数（Azimuthal-Scattering-Function）" class="headerlink" title="方位角散射函数（Azimuthal Scattering Function）"></a>方位角散射函数（Azimuthal Scattering Function）</h4><p>Marschner模型中的方位角散射：$$N&#x3D;A|2\frac{d\phi}{dh}(p,h(p,r,\phi))|^{-1}$$<br>其中$A$为衰减项，与光线的路径有关（R、TT、TRT）。第二项则出现了一个不太直观的表达：$\phi$对$h$的导数的倒数。下面尝试解释第二项的意义。</p><img src="/2025/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/02-Marschner%E6%A8%A1%E5%9E%8B/IMG-20260110151649733.png" class=""><p>这里假设毛发的横截面为单位圆，即直径等于2；出射光线相对于入射光线的偏角可以表示为：$$\phi(p,h)&#x3D;2p\gamma_t-2\gamma_i+p\pi$$$$\sin\gamma_i&#x3D;h$$假设曲线辐照度$\bar E$照亮了一根毛发，由于光线关于$h$是均匀的（平行光），因此关于$h$的单位辐照度为$E(h)&#x3D;\bar E&#x2F;2$。<br>在不考虑能量衰减的情况下，在$\mathrm dh$这样一个微小范围内入射的辐射通量应该等于在其散射方向上散射的辐射通量：<br>$$\bar{L}(\phi(h))d\phi&#x3D;E(h)dh&#x3D;(\bar{E}&#x2F;2)dh$$<br>这里等式两边的量都是辐照度（Curve Irradiance），因为$E(h)&#x3D;\bar E&#x2F;2$是单位辐照度，那自然乘上一个$\mathrm d h$仍然是辐照度。</p><p>这个式子改写成：$$\bar{L}(\phi(h))&#x3D;\left|2\frac{d\phi}{dh}\right|^{-1}\bar{E}$$</p><p>衰减项$A$需要考虑两个方面：</p><ol><li>菲涅尔衰减；</li><li>光线在毛发内部被吸收了，相关公式$T\left(\boldsymbol{\sigma}_a,h\right)&#x3D;\exp(-2\boldsymbol{\sigma}_a(1+\cos(2\boldsymbol{\gamma}_t)))$；</li></ol><p>不再做过多解释，最终衰减项可以表示为：<br>$$\begin{aligned}<br> &amp; A(0,h)&#x3D;F(\eta^{\prime},\eta^{\prime\prime},\gamma_i) \<br> &amp; A(p,h)&#x3D;\left(1-F(\eta^{\prime},\eta^{\prime\prime},\gamma_i)\right)^2F\left(\frac{1}{\eta^{\prime}},\frac{1}{\eta^{\prime\prime}},\gamma_t\right)^{p-1}T(\sigma_a^{\prime},h)^p<br>\end{aligned}$$</p><p>完整的方位角散射函数：$$\begin{aligned}<br>N(\boldsymbol{\phi}) &amp; &#x3D;\sum_pN_p(p,\phi) \<br>N_{p}(p,\phi) &amp; &#x3D;\sum_rA(p,h(p,r,\phi))\left|2\frac{d\phi}{dh}(p,h(p,r,\phi))\right|^{-1}<br>\end{aligned}$$</p><h4 id="轴线散射函数-Longitudinal-Scattering-Function"><a href="#轴线散射函数-Longitudinal-Scattering-Function" class="headerlink" title="轴线散射函数(Longitudinal Scattering Function)"></a>轴线散射函数(Longitudinal Scattering Function)</h4><p>用高斯函数近似：<br>$$\begin{gathered}<br>M_R(\theta_h)&#x3D;g(\beta_R;\theta_h-\alpha_R) \<br>M_{TT}(\theta_{h})&#x3D;g(\beta_{TT};\theta_h-\alpha_{TT}) \<br>M_{TRT}(\theta_h)&#x3D;g(\beta_{TRT};\theta_h-\alpha_{TRT})<br>\end{gathered}$$<br>其中，$\alpha$表示<strong>散射峰值在轴向方向上的偏移角度</strong>，即光线在经过反射或折射后，沿着毛发轴线方向发生了多少角度上的偏移。</p><ul><li>$\alpha_R$：R（反射）路径的纵向偏移，通常是负值（如 −10° 到 −5°），表示反射光略微向后偏。</li><li>$\alpha_{TT}&#x3D;-\frac{\alpha _{R}}{2}$：TT（透射-透射）路径的偏移较小，方向相反。</li><li>$\alpha_{TRT}&#x3D;−\frac{3\alpha_R}{2}$：TRT（透射-反射-透射）路径偏移更大，方向也相反。</li></ul><p>$\alpha$表示<strong>散射分布在轴向方向上的扩散程度</strong>，通常用标准差（stdev）来衡量。</p><ul><li>$\beta_R$：R 路径的纵向宽度，通常是 5° 到 10°，表示反射光在轴向方向上有一定扩散。</li><li>$\beta_{TT}&#x3D;\beta_R&#x2F;2$：TT 路径更集中。</li><li>$\beta_{TRT}&#x3D;2\beta_R$：TRT 路径更分散。</li></ul><h4 id="散射函数"><a href="#散射函数" class="headerlink" title="散射函数"></a>散射函数</h4><p>最终散射函数可以表示为：$$\begin{aligned}<br>S(\phi_i,\theta_i;\phi_r,\theta_r)&#x3D;<br> &amp; M_R(\theta_h)N_R(\eta^{\prime}(\eta,\theta_d);\phi)&#x2F;\cos^2\theta_d+ \<br> &amp; M_{TT}(\theta_h)N_{TT}(\eta^{\prime}(\eta,\theta_d);\phi)&#x2F;\cos^2\theta_d+ \<br> &amp; M_{TRT}(\theta_h)N_{TRT}(\eta^{\prime}(\eta^*(\phi_h),\theta_d);\phi)&#x2F;\cos^2\theta_d.<br>\end{aligned}$$<br>其中：$$N_{R}(\phi)&#x3D;N_{p}(0,\phi)$$<br>$$N_{TT}(\phi)&#x3D;N_{p}(1,\phi),$$<br>函数$N_{TRT}$的有效折射率依赖于$\phi_h$。</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>渲染</category>
      
      <category>毛发渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>毛发渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
