<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>流动的点描：基于 WCSPH 流体动力学的图像风格化实践</title>
    <link href="/2026/%E9%A3%8E%E6%A0%BC%E5%8C%96%E6%B8%B2%E6%9F%93/%E7%82%B9%E6%9F%93/04-%E5%9F%BA%E4%BA%8ESPH%E7%9A%84%E7%B2%92%E5%AD%90%E8%BF%AD%E4%BB%A3/"/>
    <url>/2026/%E9%A3%8E%E6%A0%BC%E5%8C%96%E6%B8%B2%E6%9F%93/%E7%82%B9%E6%9F%93/04-%E5%9F%BA%E4%BA%8ESPH%E7%9A%84%E7%B2%92%E5%AD%90%E8%BF%AD%E4%BB%A3/</url>
    
    <content type="html"><![CDATA[<p>最近我在做一个和点描（Stippling）相关的小项目：根据图片的灰度信息生成大量点的位置。实现这一目标的方法其实很多，比如误差扩散、Voronoi质心剖分等等。每种方法都有它独特的美感和挑战。</p><img src="/2026/%E9%A3%8E%E6%A0%BC%E5%8C%96%E6%B8%B2%E6%9F%93/%E7%82%B9%E6%9F%93/04-%E5%9F%BA%E4%BA%8ESPH%E7%9A%84%E7%B2%92%E5%AD%90%E8%BF%AD%E4%BB%A3/IMG-20260217153906896.png" class=""><p>在尝试这些算法的过程中，我突然想到：这些生成的点不就是一个个粒子吗？如果把它们看作粒子，那是不是可以借用平滑粒子流体动力学（SPH）的思想来探索新的可能性？或许能让点描的分布更自然、更具动态感。</p><p>虽然这只是一个实验性的想法，但正是这种跨领域的联想让项目变得更有趣。</p><h3 id="平滑粒子自由流体动力学sph">平滑粒子自由流体动力学（SPH）</h3><h4 id="物理量与物理量的导数">物理量与物理量的导数</h4><p>在 SPH方法中，空间中的每个粒子都“携带”特定的物理量。为了近似空间中任意位置<span class="math inline"><strong>x</strong></span> 处的物理属性 <spanclass="math inline"><strong>A</strong>(<strong>x</strong>)</span>，我们可以对邻域内的粒子进行<strong>采样</strong>，并利用核函数<span class="math inline"><em>W</em></span>（Kernel）进行加权求和：</p><p><span class="math display">$$\boldsymbol A(\boldsymbol x) \approx\sum_i \boldsymbol A_i \frac{m_i}{\rho_i} W(\|\boldsymbol x -\boldsymbol x_i\|, h) \tag {1}$$</span></p><p>其中，<spanclass="math inline"><strong>A</strong><sub><em>i</em></sub></span>是粒子 <span class="math inline"><em>i</em></span>所携带的物理属性，<spanclass="math inline"><em>m</em><sub><em>i</em></sub></span> 与 <spanclass="math inline"><em>ρ</em><sub><em>i</em></sub></span>分别为其质量与密度，<span class="math inline"><em>h</em></span>为平滑长度（Smoothing Length），决定了核函数的影响范围。</p><p>在流体仿真中，我们通常更关注物理量对空间位置的导数。为了保证计算的数值稳定性，通常采用如下<strong>对称形式</strong>的经验公式来计算粒子<span class="math inline"><em>i</em></span> 处的梯度：</p><p><span class="math display">$$\nabla \boldsymbol A_i = \rho_i \sum_jm_j \left( \frac{\boldsymbol A_i}{\rho_i^2} + \frac{\boldsymbolA_j}{\rho_j^2} \right) \nabla_{\boldsymbol x_i} W(\|\boldsymbol x_i -\boldsymbol x_j\|, h) \tag {2}$$</span></p><p><strong>需要注意的是：</strong>这种形式并非数学意义上的严格导数，但在物理仿真中至关重要。它通过强制算子的<strong>对称性</strong>，确保了粒子间相互作用力的守恒（如动量守恒）。如果导数形式不对称，系统可能会产生非物理的数值驱动力，导致能量不守恒或模拟崩溃。</p><h3 id="实现步骤">实现步骤</h3><p>本项目的整体实现流程与流体动力学仿真基本一致，主要分为以下四个核心步骤：</p><ol type="1"><li><strong>密度场计算</strong>：遍历每个粒子，根据其邻域粒子的分布计算局部密度<span class="math inline"><em>ρ</em></span>。</li><li><strong>受力与加速度求解</strong>：基于密度场和状态方程（EOS）计算压力梯度，进而导出每个粒子的加速度<span class="math inline"><strong>a</strong></span>。</li><li><strong>速度更新</strong>：利用数值积分（如显式欧拉法）根据加速度迭代粒子的瞬时速度<span class="math inline"><strong>v</strong></span>。</li><li><strong>位置平移</strong>：根据更新后的速度调整粒子坐标，完成空间位置的迭代。</li></ol><h4 id="密度场计算">密度场计算</h4><p>在本方案中，我采用了 <strong>弱可压缩 SPH (WCSPH)</strong>的相关理论。首先，根据粒子间的相对位置，利用公式<spanclass="math inline">(1)</span>近似计算连续的密度场：</p><p><spanclass="math display"><em>ρ</em>(<strong>x</strong>) ≈ ∑<sub><em>i</em></sub><em>m</em><sub><em>i</em></sub><em>W</em>(∥<strong>x</strong> − <strong>x</strong><sub><em>i</em></sub>∥, <em>h</em>)</span></p><h4 id="受力与加速度求解">受力与加速度求解</h4><p>随后，需要根据密度场推导速度对时间的导数（即加速度 <spanclass="math inline"><strong>a</strong></span>）。在流体力学中，粒子的运动方程由下式给出：</p><p><span class="math display">$$\frac{\mathrm{D} \boldsymbolv}{\mathrm{D} t} = -\frac{1}{\rho} \nabla p + \boldsymbol g \tag{3}$$</span></p><p>其中，<span class="math inline"><em>p</em></span> 为标量压力场，<spanclass="math inline"><strong>g</strong></span>代表重力或其他外部驱动力，<span class="math inline"><em>ρ</em></span>即为前文求解的局部密度。为了闭合方程组，我们引入<strong>状态方程(Equation of State, EOS)</strong> 来显式计算压力：</p><p><span class="math display">$$p = B \left( \left( \frac{\rho}{\rho_0}\right)^\gamma - 1 \right) \tag {4}$$</span></p><p>在该公式中，<span class="math inline"><em>B</em></span>为<strong>体积模量 (BulkModulus)</strong>，用于衡量流体抵抗压缩的能力，其作用类似于弹簧质点系统中的杨氏模量。<spanclass="math inline"><em>ρ</em><sub>0</sub></span> 为<strong>参考密度(Rest Density)</strong>。从物理直观上理解：当局部密度 <spanclass="math inline"><em>ρ</em></span> 大于 <spanclass="math inline"><em>ρ</em><sub>0</sub></span>时，粒子感受到正向压力并趋于向外扩张；反之，当密度低于参考密度时，产生的负压（吸引力）会促使粒子向内收缩，从而维持系统的质量分布平衡。</p><blockquote><p>为了使迭代后的粒子分布与目标图像的灰度分布一致，我将图像的<strong>灰度值映射为粒子的参考密度<spanclass="math inline"><em>ρ</em><sub>0</sub></span></strong>。具体实现上，通过对粒子位置处的灰度图进行<strong>双线性插值</strong>来确定该点的<spanclass="math inline"><em>ρ</em><sub>0</sub></span>。此外，还可以对原始灰度值进行非线性变换，以灵活调整最终生成的粒子疏密程度。</p></blockquote><p>注意到公式 <span class="math inline">(3)</span>中涉及的是压力梯度项，因此我们利用公式 <spanclass="math inline">(2)</span> 给出压力梯度的离散化表达：</p><p><span class="math display">$$\nabla p_i = \rho_i \sum_j m_j \left(\frac{p_i}{\rho_i^2} + \frac{p_j}{\rho_j^2} \right) \nabla_{\boldsymbolx_i} W(\|\boldsymbol x_i - \boldsymbol x_j\|, h) $$</span></p><p>通过该式，我们便得到了物质导数 <spanclass="math inline">$\frac{\mathrm{D} \boldsymbol v}{\mathrm{D}t}$</span> 中的压力贡献项（即内力项）。</p><p>对于第二项<strong>外力</strong> <spanclass="math inline"><strong>g</strong></span>，我们可以直接对目标灰度图求取梯度。引入该项的物理意义在于：通过灰度梯度引导粒子运动，从而有效减少粒子从高灰度（高目标密度）区域向低灰度区域的非预期扩散，强化粒子分布对图像特征的捕捉能力。当然这也只是一个可选项，在这个任务中<span class="math inline"><strong>g</strong></span>可以直接设置为0。</p><p>顺带一提，我在这里选用的核函数（KernelFunction）为经典的<strong>三次样条核（Cubic SplineKernel）</strong>，其数学表达式如下：</p><p><span class="math display">$$W(q, h) = \sigma_d\begin{cases}6(q^3 - q^2) + 1 &amp; 0 \leq q \leq \frac{1}{2} \\2(1 - q)^3 &amp; \frac{1}{2} &lt; q \leq 1 \\0 &amp; \text{otherwise}\end{cases}$$</span></p><p>其中，<span class="math inline">$q = \frac{\|\boldsymbolr\|}{h}$</span> 代表粒子间距与平滑长度的比值。<spanclass="math inline"><em>σ</em><sub><em>d</em></sub></span>为保证积分单位化的<strong>归一化系数</strong>。由于本项目处理的是二维空间情况，对应的归一化系数取值为<span class="math inline">$\sigma_d = \frac{40}{7\pi h^2}$</span>。</p><p>该核函数具有良好的** 紧支集(Compact Support) **特性，即当粒子间距超过<span class="math inline"><em>h</em></span>时，相互作用力自动降为零，这极大地优化了近邻搜索的计算效率。</p><h4 id="速度与位置更新">速度与位置更新</h4><p>在时间积分方案上，本项目直接采用<strong>显式欧拉法（Explicit EulerMethod）</strong>来更新粒子的运动状态。其离散迭代公式如下：</p><ol type="1"><li><strong>速度更新</strong>： <span class="math display">$$\boldsymbolv_{t+1} = \boldsymbol v_{t} + \Delta t \frac{\mathrm{D} \boldsymbolv}{\mathrm{D} t}$$</span></li><li><strong>位置更新</strong>： <spanclass="math display"><strong>x</strong><sub><em>t</em> + 1</sub> = <strong>x</strong><sub><em>t</em></sub> + <em>Δ</em><em>t</em><strong>v</strong><sub><em>t</em> + 1</sub></span></li></ol><p>至此，系统完成了一次完整的时间步迭代。</p><h3 id="效果展示">效果展示</h3><p>让我们来看看初步的实验结果：</p><img src="/2026/%E9%A3%8E%E6%A0%BC%E5%8C%96%E6%B8%B2%E6%9F%93/%E7%82%B9%E6%9F%93/04-%E5%9F%BA%E4%BA%8ESPH%E7%9A%84%E7%B2%92%E5%AD%90%E8%BF%AD%E4%BB%A3/IMG-20260217153907084.gif" class=""><p>emmm……从动图中可以看出，粒子虽然能够成功地向高灰度（高密度目标）区域聚集，但……总感觉哪里有点怪怪的？相对于CVT和误差扩散生成的点集视觉上并不均匀，点会更加倾向于进入高密度区域，并在边缘聚集。</p><p>尽管如此，这样的结果也表明了前面相关步骤是正确可行的，也算了对流体动力学有了一个初步的认知，是一次蛮有意思的尝试。</p><h3 id="参考文献">参考文献</h3><ol type="1"><li><a href="https://arxiv.org/abs/2009.06944">Smoothed ParticleHydrodynamics Techniques for the Physics Based Simulation of Fluids andSolids</a></li><li><ahref="https://www.bilibili.com/video/BV1ZK411H7Hc/?spm_id_from=333.337.search-card.all.click">Games201</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>非真实感渲染</category>
      
      <category>风格化渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>流体动力学</tag>
      
      <tag>点描</tag>
      
      <tag>风格化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚幻引擎用SceneViewExtension实现简单后处理效果</title>
    <link href="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/"/>
    <url>/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>前两篇文章介绍了虚幻引擎中计算管线和图形管线的调用流程，但示例中仅在某个<code>Actor</code> 的 <code>BeginPlay()</code>中调用了一次。如果希望<strong>在每一帧都执行这个自定义管线</strong>，又该如何实现呢？</p><p>这时就需要借助<code>SceneViewExtension</code>。<code>SceneViewExtension</code>为我们提供了渲染流程中多个阶段的Hook，既涵盖<strong>游戏线程</strong>，也包含<strong>渲染线程</strong>。通过重载对应的虚函数，我们可以实现例如：</p><ol type="1"><li>修改视口（View）的相关属性；</li><li>获取RDG中的相关资源，例如<code>GBuffer</code>、<code>SceneColor</code>等;</li><li>注入并执行自定义着色器；</li></ol><p>然而，正如其名字所暗示的那样，<code>SceneViewExtension</code>本质上只是一个“扩展点”，它并不会改变 Unreal Engine内部真正的光照模型。即使我们在某个 Hook 中基于 GBuffer重新计算了一套完整的光照结果，也只是<strong>在现有渲染结果之上额外进行了一次计算</strong>，并不会影响引擎内部的光照流程本身。<br />如果希望真正替换或重写光照模型，就必须修改 Unreal Engine的渲染源码。相比之下，这一点确实要比 URP 麻烦不少。</p><p>在理解了这一限制之后，<code>SceneViewExtension</code>更适合用于一些<strong>非侵入式的渲染扩展</strong>。因此，本文将介绍如何利用<code>SceneViewExtension</code>实现一个简单的后处理效果——一个“丐版”的复古电视机滤镜。本文使用的虚幻引擎版本仍然是<strong>5.7</strong>。</p><p>代码参考了Github上的一个模板：<ahref="https://github.com/A57R4L/SceneViewExtensionTemplate">SceneViewExtensionTemplate</a></p><p>本项目的源码：<ahref="https://github.com/OnikataHoshio/LearnRDG">OnikataHoshio/LearnRDG</a></p><h3 id="配置sve插件">配置SVE插件</h3><h4 id="配置虚拟路径映射">配置虚拟路径映射</h4><p>打开虚幻引擎，依次点击 <strong>编辑 → 插件 →添加</strong>，创建一个新的插件，这里将其命名为<strong>RetroTV</strong>。<br />创建完成后，插件结构如下图所示： <img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/IMG-20260131211504097.png" class=""> 随后打开生成的<strong>C++ 项目</strong>，在 <code>RetroTV.cpp</code> 中为插件添加<code>Shaders</code> 目录的<strong>虚拟路径映射</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FRetroTVModule::StartupModule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module</span><br>FString PluginShaderDir = FPaths::<span class="hljs-built_in">Combine</span>(FPaths::<span class="hljs-built_in">ProjectPluginsDir</span>(), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/RetroTV/Shaders&quot;</span>));<br><span class="hljs-built_in">AddShaderSourceDirectoryMapping</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Plugins/RetroTVShaders&quot;</span>), PluginShaderDir);<br>&#125;<br></code></pre></td></tr></table></figure> 通过这一步配置，我们就可以将所有与该插件相关的<code>.usf</code> 着色器文件，直接放在插件目录下的 <code>Shaders</code>文件夹中，而不需要放入引擎或项目的全局 Shader 目录。最终的目录结构如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LearnRDG<br>|-Content<br>|-Plugins<br>|-RetroTV<br>|-Shaders<br>|-Source<br></code></pre></td></tr></table></figure></p><h4 id="配置模块依赖">配置模块依赖</h4><p>接下来需要在 <code>RetroTV.Build.cs</code>中配置插件所需的模块依赖与路径依赖。<br />其中，自定义着色器和 RDG 功能依赖于<code>RenderCore</code>、<code>Renderer</code> 以及 <code>RHI</code>模块；<code>Projects</code> 模块用于配置 Shader 的虚拟路径映射；而<code>DeveloperSettings</code>则用于辅助我们读取和引用部分配置或资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">var EngineDir = Path.<span class="hljs-built_in">GetFullPath</span>(Target.RelativeEnginePath);<br><br>PrivateIncludePaths.<span class="hljs-built_in">AddRange</span>(<br><span class="hljs-keyword">new</span> string[] &#123;<br><span class="hljs-comment">// ... add other private include paths required here ...</span><br><span class="hljs-comment">// Required to find PostProcessing includes f.ex. screenpass.h &amp; TranslucentPassResource.h</span><br>Path.<span class="hljs-built_in">Combine</span>(EngineDir, <span class="hljs-string">&quot;Source/Runtime/Renderer/Private&quot;</span>),<br>Path.<span class="hljs-built_in">Combine</span>(EngineDir, <span class="hljs-string">&quot;Source/Runtime/Renderer/Internal&quot;</span>)<br>&#125;<br>);<br><br>PrivateDependencyModuleNames.<span class="hljs-built_in">AddRange</span>(<br><span class="hljs-keyword">new</span> string[]<br>&#123;<br><span class="hljs-string">&quot;CoreUObject&quot;</span>,<br><span class="hljs-string">&quot;Engine&quot;</span>,<br><span class="hljs-string">&quot;Slate&quot;</span>,<br><span class="hljs-string">&quot;SlateCore&quot;</span>,<br><span class="hljs-comment">// ... add private dependencies that you statically link with here ...</span><br><span class="hljs-string">&quot;RenderCore&quot;</span>,<br><span class="hljs-string">&quot;Renderer&quot;</span>,<br><span class="hljs-string">&quot;RHI&quot;</span>,<br><span class="hljs-string">&quot;Projects&quot;</span>,<br><span class="hljs-string">&quot;DeveloperSettings&quot;</span><br>&#125;<br>);<br></code></pre></td></tr></table></figure><h4 id="修改retrotv.uplugin">修改RetroTV.uplugin</h4><p>打开<code>RetroTV.uplugin</code>，将<code>Modules</code> 中的<code>LoadingPhase</code> 从 <code>Default</code> 修改为<code>PostConfigInit</code>，否则可能会出现 <strong>Shader在虚拟路径尚未建立之前就被编译</strong>的问题，从而导致编译失败或路径无法解析。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-string">&quot;Modules&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;RetroTV&quot;</span>,<br><span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br><span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;PostConfigInit&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="编写usf文件">编写usf文件</h3><p>我希望实现一个“丐版”的复古电视风格效果，整体可以拆分为以下四个主要环节：</p><ol type="1"><li>镜头畸变；</li><li>电视机蒙版；</li><li>噪点；</li><li>扫描线。</li></ol><p>除此之外，还可以进一步加入诸如高斯模糊、UV突变等效果。不过考虑到这只是一个用于练手和验证流程的小工程，本文中不会将实现设计得过于复杂。</p><p>此外，由于如何编写usf文件不是本篇文章的重点，因此直接给出相关代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Custom CS PostProcessing Shader</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Public/Platform.ush&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Private/Common.ush&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Private/ScreenPass.ush&quot;</span></span><br><br>Texture2D OriginalSceneColor;<br>Texture2D TVMaskTexture;<br>Texture2D ScanLineTexture;<br><br><span class="hljs-type">float</span> RetroScaleFactor;<br><span class="hljs-type">float</span> LensDistortionK1; <br><span class="hljs-type">float</span> LensDistortionK2; <br><br><span class="hljs-type">float</span> VignetteStart;  <br><span class="hljs-type">float</span> VignetteEnd; <br><span class="hljs-type">float</span> VignettePower;   <br><span class="hljs-type">float</span> VignetteIntensity;  <br><br><span class="hljs-type">float</span> ScanlineSpeed;<br><span class="hljs-type">float</span> ScanlineIntensity;<br><span class="hljs-type">float</span> ScanlineScale;<br><br><span class="hljs-built_in">SCREEN_PASS_TEXTURE_VIEWPORT</span>(SceneColorViewport)<br><br>RWTexture2D&lt;float4&gt; Output;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CalcaulateLuminance</span><span class="hljs-params">(float3 color)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dot</span>(color, <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.2126f</span>, <span class="hljs-number">0.7152f</span>, <span class="hljs-number">0.0722f</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetNoise</span><span class="hljs-params">(float2 p, <span class="hljs-type">float</span> offset)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">frac</span>(<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">dot</span>(p + offset, <span class="hljs-built_in">float2</span>(<span class="hljs-number">12.9898</span>, <span class="hljs-number">78.233</span>))) * <span class="hljs-number">43758.5453</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">HDRToLDR</span><span class="hljs-params">(float3 color)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> luma = <span class="hljs-built_in">CalcaulateLuminance</span>(color);<br>    <span class="hljs-keyword">return</span> luma / (<span class="hljs-number">1.0f</span> + luma); <br>&#125;<br><br><span class="hljs-function">float4 <span class="hljs-title">CalculateColorGrain</span><span class="hljs-params">(float3 hdrColor, float2 uv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> lumaLDR = <span class="hljs-built_in">HDRToLDR</span>(hdrColor);<br>    <br>    float2 seed = uv + View.StateFrameIndexMod8; <br>    <br>    float3 noise;<br>    noise.r = <span class="hljs-built_in">GetNoise</span>(seed , <span class="hljs-number">0.1337</span>);       <br>    noise.g = <span class="hljs-built_in">GetNoise</span>(seed , <span class="hljs-number">0.4242</span>);    <br>    noise.b = <span class="hljs-built_in">GetNoise</span>(seed , <span class="hljs-number">0.5342</span>);   <br><br>    <span class="hljs-type">float</span> strength = <span class="hljs-number">1.0</span> - <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">abs</span>(lumaLDR - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>);<br><br>    float3 grain = (noise - <span class="hljs-number">0.5f</span>) * strength * lumaLDR; <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">float4</span>(grain, <span class="hljs-number">1.0f</span>);<br>&#125;<br><br><span class="hljs-function">float2 <span class="hljs-title">CalculateDistortedUV</span><span class="hljs-params">(float2 screenCoord, <span class="hljs-type">float</span> viewAspect)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 p = screenCoord;<br>    p.x *= viewAspect;<br><br>    <span class="hljs-type">float</span> r2 = <span class="hljs-built_in">dot</span>(p, p);<br>    <span class="hljs-type">float</span> scale = <span class="hljs-number">1.0f</span> + LensDistortionK1 * r2 + LensDistortionK2 * (r2 * r2);<br>    float2 distortedP = p * scale;<br>    distortedP.x /= viewAspect;<br><br>    float2 distortedUV = (distortedP + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-keyword">return</span> distortedUV;<br>&#125;<br><br><span class="hljs-function">float4 <span class="hljs-title">CalculateDistortedColor</span><span class="hljs-params">(float2 distortedUV, <span class="hljs-type">float</span> viewAspect)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 uvMin = <span class="hljs-built_in">float2</span>(SceneColorViewport_ViewportMin) * SceneColorViewport_ExtentInverse + SceneColorViewport_ExtentInverse;<br>    float2 uvMax = <span class="hljs-built_in">float2</span>(SceneColorViewport_ViewportMin + SceneColorViewport_ViewportSize) * SceneColorViewport_ExtentInverse - SceneColorViewport_ExtentInverse;<br><br>    <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">any</span>(distortedUV &lt; uvMin) || <span class="hljs-built_in">any</span>(distortedUV &gt; uvMax);<br><br>    float2 safeUV = <span class="hljs-built_in">clamp</span>(distortedUV, uvMin, uvMax);<br>    float4 distortedColor = OriginalSceneColor.<span class="hljs-built_in">SampleLevel</span>(GlobalBilinearClampedSampler, safeUV, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (outside) distortedColor = <span class="hljs-built_in">float4</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> distortedColor;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CalculateVignette</span><span class="hljs-params">(float2 distortedUV)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 centeredUV = distortedUV * <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(centeredUV);<br><br>    <span class="hljs-type">float</span> vignette = <span class="hljs-built_in">smoothstep</span>(VignetteStart, VignetteEnd, dist);<br>    vignette = <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span> - vignette, VignettePower);<br>    vignette = <span class="hljs-built_in">lerp</span>(<span class="hljs-number">1.0f</span>, vignette, VignetteIntensity);<br>    <br>    <span class="hljs-keyword">return</span> vignette;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CalculateScanline</span><span class="hljs-params">(float2 uv)</span></span><br><span class="hljs-function"></span>&#123;<br>    uv *= ScanlineScale;<br><br>    uv.y += View.RealTime * ScanlineSpeed;<br><br>    <span class="hljs-type">float</span> scanline = ScanLineTexture.<span class="hljs-built_in">SampleLevel</span>(GlobalBilinearWrappedSampler,uv,<span class="hljs-number">0</span>).r;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0f</span> - scanline * ScanlineIntensity;<br>&#125;<br><br><br>[<span class="hljs-built_in">numthreads</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainCS</span><span class="hljs-params">(uint2 DispatchThreadId : SV_DispatchThreadID)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">any</span>(DispatchThreadId &gt;= SceneColorViewport_ViewportSize)) <span class="hljs-keyword">return</span>;<br><br>    float2 sampleUV = (<span class="hljs-built_in">float2</span>(SceneColorViewport_ViewportMin) + (<span class="hljs-built_in">float2</span>(DispatchThreadId) + <span class="hljs-number">0.5f</span>)) * SceneColorViewport_ExtentInverse;<br>    float2 screenCoord = sampleUV * <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.0f</span>;<br>    screenCoord *= RetroScaleFactor;<br><br>    <span class="hljs-type">float</span> viewAspect = (<span class="hljs-type">float</span>)SceneColorViewport_ViewportSize.x / (<span class="hljs-type">float</span>)SceneColorViewport_ViewportSize.y;<br>    <br>    float2 distortedUV = <span class="hljs-built_in">CalculateDistortedUV</span>(screenCoord, viewAspect);<br><br>    float4 distortedColor = <span class="hljs-built_in">CalculateDistortedColor</span>(distortedUV, viewAspect);<br>    <span class="hljs-type">float</span> luminance = <span class="hljs-built_in">CalcaulateLuminance</span>(distortedColor.rgb);<br>    float4 grain = <span class="hljs-built_in">CalculateColorGrain</span>(luminance, distortedUV * SceneColorViewport_ViewportSize);<br><br>    <span class="hljs-type">float</span> vignette = <span class="hljs-built_in">CalculateVignette</span>(distortedUV);<br>    <span class="hljs-type">float</span> scanline = <span class="hljs-built_in">CalculateScanline</span>(sampleUV);<br>    float4 tvMaskColor = TVMaskTexture.<span class="hljs-built_in">SampleLevel</span>(GlobalBilinearClampedSampler, sampleUV, <span class="hljs-number">0</span>);<br><br>    Output[SceneColorViewport_ViewportMin + DispatchThreadId] = (distortedColor + grain) * tvMaskColor * vignette * scanline;<br>&#125;<br><br></code></pre></td></tr></table></figure>暂且不讨论具体的着色器实现逻辑，可以注意到我们在着色器中定义了多种不同类型的全局变量，例如<code>Texture2D</code>、<code>float</code> 以及<code>RWTexture2D&lt;float4&gt;</code>。这些变量在 <strong>C++侧有着各自不同的声明和绑定方式</strong>，需要分别进行处理。</p><p>除了自定义变量之外，我们还使用了一些 Unreal Engine中已经预先声明好的内建变量。其中之一是<br /><code>SCREEN_PASS_TEXTURE_VIEWPORT(SceneColorViewport)</code>，该宏能够为我们提供与当前视口尺寸相关的一系列参数，因此需要引入头文件<code>ScreenPass.ush</code>。<br />另一个常用的内建变量是<code>View</code>，它包含了大量与视图相关的运行时数据，例如本文着色器中用到的<code>View.RealTime</code>。</p><h3 id="创建自定义sceneviewextension">创建自定义SceneViewExtension</h3><h4 id="自定义sve类的.h文件声明">自定义SVE类的.h文件声明</h4><p>接下来就可以基于自定义着色器来编写对应的<code>SceneViewExtension</code> 了。首先新建一个名为<code>RetroTVSceneViewExtension</code> 的 C++ 类，并继承自<code>FSceneViewExtensionBase</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RETROTV_API</span> FRetroTVSceneViewExtension : <span class="hljs-keyword">public</span> FSceneViewExtensionBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FRetroTVSceneViewExtension</span>(<span class="hljs-type">const</span> FAutoRegister&amp; AutoRegister);<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetTVMaskTexture</span><span class="hljs-params">(<span class="hljs-type">const</span> UTexture2D* InTexture)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetScanLineTexture</span><span class="hljs-params">(<span class="hljs-type">const</span> UTexture2D* InTexture)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SubscribeToPostProcessingPass</span><span class="hljs-params">(EPostProcessingPass PassId, <span class="hljs-type">const</span> FSceneView&amp; View, FAfterPassCallbackDelegateArray&amp; InOutPassCallbacks, <span class="hljs-type">bool</span> bIsPassEnabled)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-function">FScreenPassTexture <span class="hljs-title">CustomPostProcessing</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">const</span> FSceneView&amp; View, <span class="hljs-type">const</span> FPostProcessMaterialInputs&amp; Inputs)</span></span>;<br><br><br><span class="hljs-keyword">private</span>:<br>FTextureRHIRef TVMaskTextureRHI;<br>FTextureRHIRef ScanLineTextureRHI;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个 SVE 类中，我们可以通过重写诸如<br /><code>SetupViewFamily(FSceneViewFamily&amp; InViewFamily)</code>、<br /><code>BeginRenderViewFamily(FSceneViewFamily&amp; InViewFamily)</code><br />等函数来修改视口属性，或在渲染流程中注入自定义 Pass。</p><p>不过，由于本文实现的是一个<strong>后处理效果</strong>，并不需要介入更早的渲染阶段，因此只需重写<br /><code>SubscribeToPostProcessingPass( EPostProcessingPass PassId, const FSceneView&amp; View, FAfterPassCallbackDelegateArray&amp; InOutPassCallbacks, bool bIsPassEnabled )</code><br />这一函数即可。该函数的主要作用是将我们自定义的后处理流程（以函数的形式）注册为某个后处理阶段的回调，并在对应的渲染阶段自动被调用，也就是代码中的<code>CustomPostProcessing(FRDGBuilder&amp; GraphBuilder, const FSceneView&amp; View, const FPostProcessMaterialInputs&amp; Inputs)</code>。回调函数的参数有严格的要求，不可随意更改。</p><p>此外，着色器中还使用了两个 <strong>RDG之外的外部纹理资源</strong>，因此需要分别创建两个资源句柄<code>TVMaskTextureRHI</code> 和<code>ScanLineTextureRHI</code>，并正确配置它们对应的 <code>Set</code>方法。</p><h4 id="自定义sve的.cpp文件">自定义SVE的.cpp文件</h4><h5 id="注册并编译着色器">注册并编译着色器</h5><p>在<code>RetroTVSceneViewExtension.cpp</code>文件中，首先需要创建一个和<code>.usf</code>文件对应的计算着色器类，相关代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RETROTV_API</span> FLenDistortionCS : <span class="hljs-keyword">public</span> FGlobalShader<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DECLARE_GLOBAL_SHADER</span>(FLenDistortionCS);<br><span class="hljs-built_in">SHADER_USE_PARAMETER_STRUCT</span>(FLenDistortionCS, FGlobalShader);<br><br><span class="hljs-built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters, )<br><span class="hljs-built_in">SHADER_PARAMETER_STRUCT</span>(FScreenPassTextureViewportParameters, SceneColorViewport)<br><span class="hljs-built_in">SHADER_PARAMETER_STRUCT_REF</span>(FViewUniformShaderParameters, View)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, RetroScaleFactor)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, LensDistortionK1)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, LensDistortionK2)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, VignetteStart)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, VignetteEnd)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, VignettePower)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, VignetteIntensity)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, ScanlineSpeed)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, ScanlineIntensity)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, ScanlineScale)<br><span class="hljs-built_in">SHADER_PARAMETER_RDG_TEXTURE</span>(Texture2D, OriginalSceneColor)<br><span class="hljs-built_in">SHADER_PARAMETER_TEXTURE</span>(Texture2D, TVMaskTexture)<br><span class="hljs-built_in">SHADER_PARAMETER_TEXTURE</span>(Texture2D, ScanLineTexture)<br><span class="hljs-built_in">SHADER_PARAMETER_RDG_TEXTURE_UAV</span>(RWTexture2D&lt;float4&gt;, Output)<br><span class="hljs-built_in">END_SHADER_PARAMETER_STRUCT</span>()<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ShouldCompilePermutation</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">IsFeatureLevelSupported</span>(Parameters.Platform, ERHIFeatureLevel::SM5);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ModifyCompilationEnvironment</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment)</span></span><br><span class="hljs-function"></span>&#123;<br>OutEnvironment.<span class="hljs-built_in">SetDefine</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;THREADS_X&quot;</span>), <span class="hljs-number">8</span>);<br>OutEnvironment.<span class="hljs-built_in">SetDefine</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;THREADS_Y&quot;</span>), <span class="hljs-number">8</span>);<br>OutEnvironment.<span class="hljs-built_in">SetDefine</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;THREADS_Z&quot;</span>), <span class="hljs-number">1</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_GLOBAL_SHADER</span>(FLenDistortionCS, <span class="hljs-string">&quot;/Plugins/RetroTVShaders/LensDistortion.usf&quot;</span>, <span class="hljs-string">&quot;MainCS&quot;</span>, SF_Compute);<br></code></pre></td></tr></table></figure> 我们通过 <code>BEGIN_SHADER_PARAMETER_STRUCT()</code>显式声明该着色器所使用的所有全局变量。只有在这里正确地定义并绑定这些参数，才能确保C++ 侧的数据被正确传递到着色器中：</p><ol type="1"><li><code>SHADER_PARAMETER</code>：用于声明基础类型参数，例如<code>float</code>、<code>int</code>、<code>uint</code>等常量数据；</li><li><code>SHADER_PARAMETER_RDG_TEXTURE</code>：用于声明 <strong>由 RDG创建并管理的只读纹理资源</strong>，通常作为 Shader ResourceView（SRV）使用；</li><li><code>SHADER_PARAMETER_RDG_TEXTURE</code>：用于声明 <strong>位于 RDG之外、由 RHI 管理的只读纹理资源</strong>，常用于外部导入的纹理（如<code>UTexture2D</code>）；</li><li><code>SHADER-PARAMETER_RDG_TEXTURE_UAV</code>：用于声明 <strong>由RDG 创建并管理的可读写纹理资源</strong>，通常作为 Compute Shader的输出目标（UAV）；</li><li><code>SHADER_PARAMETER_STRUCT</code>：用于内嵌一个<strong>值拷贝形式的参数结构体</strong>，例如视口参数、常量打包参数等；</li><li><code>SHADER_PARAMETER_STRUCT_REF</code>：用于引用一个<strong>由引擎统一维护的参数结构体</strong>，常见的例子是<code>View</code>、<code>SceneTextures</code> 等；</li></ol><p>最后，通过调用 <code>IMPLEMENT_GLOBAL_SHADER()</code>将该着色器注册到 Unreal Engine中，确保其在启动或编译阶段被正确编译，并能够被引擎正常识别和使用。</p><h5 id="声明控制台变量">声明控制台变量</h5><p>由于控制台变量本身具备良好的线程安全性，因此这里使用控制台变量来控制着色器中的相关参数。相关代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;int32&gt; <span class="hljs-title">CVarShaderOn</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Enable RetroTV SceneViewExtension \n&quot;</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot; 0: OFF;&quot;</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot; 1: ON.&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarScaleFactor</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.ScaleFactor&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">1.0f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update ScaleFactor \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarLenDistortionK1</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.LenDistortionK1&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.05f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update LenDistortionK1 \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarLenDistortionK2</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.LenDistortionK2&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.02f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update LenDistortionK2 \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarVignetteStart</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.VignetteStart&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.7f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update VignetteStart \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarVignetteEnd</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.VignetteEnd&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">1.0f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update VignetteEnd \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarVignettePower</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.VignettePower&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">2.0f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update VignettePower \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarVignetteIntensity</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.VignetteIntensity&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.7f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update VignetteIntensity \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarScanlineSpeed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.ScanlineSpeed&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.2f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update ScanlineSpeed \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarScanlineIntensity</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.ScanlineIntensity&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0.7f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update ScanlineIntensity \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br><span class="hljs-function">TAutoConsoleVariable&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">CVarScanlineScale</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;r.RetroTV.ScanlineScale&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">5.0f</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;Update ScanlineScale \n&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">ECVF_RenderThreadSafe)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h5 id="设置纹理资源">设置纹理资源</h5><p>我们还需要设置两个外部纹理资源（由 RHI维护的纹理资源），相关代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FRetroTVSceneViewExtension::SetTVMaskTexture</span><span class="hljs-params">(<span class="hljs-type">const</span> UTexture2D* InTexture)</span></span><br><span class="hljs-function"></span>&#123;<br>FTextureRHIRef NewRHI = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">if</span> (InTexture &amp;&amp; InTexture-&gt;<span class="hljs-built_in">GetResource</span>())<br>&#123;<br>NewRHI = InTexture-&gt;<span class="hljs-built_in">GetResource</span>()-&gt;TextureRHI;<br>&#125;<br><br><span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(RetroTV_SetExtraTexture)<br>(<br>[<span class="hljs-keyword">this</span>, NewRHI](FRHICommandListImmediate&amp; RHICmdList)<br>&#123;<br>TVMaskTextureRHI = NewRHI;<br>&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FRetroTVSceneViewExtension::SetScanLineTexture</span><span class="hljs-params">(<span class="hljs-type">const</span> UTexture2D* InTexture)</span></span><br><span class="hljs-function"></span>&#123;<br>FTextureRHIRef NewRHI = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">if</span> (InTexture &amp;&amp; InTexture-&gt;<span class="hljs-built_in">GetResource</span>())<br>&#123;<br>NewRHI = InTexture-&gt;<span class="hljs-built_in">GetResource</span>()-&gt;TextureRHI;<br>&#125;<br><br><span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(RetroTV_SetExtraTexture)<br>(<br>[<span class="hljs-keyword">this</span>, NewRHI](FRHICommandListImmediate&amp; RHICmdList)<br>&#123;<br>ScanLineTextureRHI = NewRHI;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>由于输入纹理最初位于<strong>游戏线程</strong>，而渲染相关资源只能在<strong>渲染线程</strong>上安全访问，因此需要借助<code>ENQUEUE_RENDER_COMMAND</code>将这些资源的引用安全地传递到渲染线程中进行处理。</p><h5 id="注册回调函数">注册回调函数</h5><p>Unreal Engine的后处理流程被划分为多个不同的阶段，具体的阶段名称可以在<code>EPostProcessingPass</code>枚举中查阅。一般情况下，将自定义后处理插入到 <strong>MotionBlur</strong>阶段即可满足需求。<br />我在实际测试中，将 Pass插入到其他阶段时，往往会遇到诸如黑屏等问题，因此这里选择使用相对稳定的MotionBlur 阶段。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FRetroTVSceneViewExtension::SubscribeToPostProcessingPass</span><span class="hljs-params">(EPostProcessingPass PassId, <span class="hljs-type">const</span> FSceneView&amp; View,</span></span><br><span class="hljs-params"><span class="hljs-function">FAfterPassCallbackDelegateArray&amp; InOutPassCallbacks, <span class="hljs-type">bool</span> bIsPassEnabled)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (PassId == EPostProcessingPass::MotionBlur)<br>&#123;<br>InOutPassCallbacks.<span class="hljs-built_in">Add</span>(FAfterPassCallbackDelegate::<span class="hljs-built_in">CreateRaw</span>(<span class="hljs-keyword">this</span>, &amp;FRetroTVSceneViewExtension::CustomPostProcessing));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="编写自定义的pass">编写自定义的Pass</h5><p>这一步的实现也相对简单，只需要将前面准备好的参数传递给着色器即可。由于使用的是计算管线，不需要配置图形管线中诸如顶点布局、渲染状态等相关参数，因此整体流程显得更加简洁明了。代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FScreenPassTexture <span class="hljs-title">FRetroTVSceneViewExtension::CustomPostProcessing</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">const</span> FSceneView&amp; SceneView,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FPostProcessMaterialInputs&amp; Inputs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> FSceneViewFamily&amp; ViewFamily = *SceneView.Family;<br><br><span class="hljs-type">const</span> FScreenPassTexture&amp; SceneColor = FScreenPassTexture::<span class="hljs-built_in">CopyFromSlice</span>(GraphBuilder, Inputs.<span class="hljs-built_in">GetInput</span>(EPostProcessMaterialInput::SceneColor));<br><br><span class="hljs-keyword">if</span> (!SceneColor.<span class="hljs-built_in">IsValid</span>() || CVarShaderOn.<span class="hljs-built_in">GetValueOnRenderThread</span>() == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> SceneColor;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> FScreenPassTextureViewport <span class="hljs-title">SceneColorViewport</span><span class="hljs-params">(SceneColor)</span></span>;<br><br><span class="hljs-built_in">RDG_EVENT_SCOPE</span>(GraphBuilder, <span class="hljs-string">&quot;RetroTV Postprocess Effect&quot;</span>);<br>&#123;<br>FGlobalShaderMap* GlobalShaderMap = <span class="hljs-built_in">GetGlobalShaderMap</span>(ViewFamily.<span class="hljs-built_in">GetFeatureLevel</span>());<br><span class="hljs-function">TShaderMapRef&lt;FLenDistortionCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GlobalShaderMap)</span></span>;<br><br>FRDGTextureDesc OutputDesc;<br>&#123;<br>OutputDesc = SceneColor.Texture-&gt;Desc;<br><span class="hljs-comment">// OutputDesc.Reset();</span><br>OutputDesc.Flags |= TexCreate_UAV;<br>OutputDesc.Flags &amp;= ~(TexCreate_RenderTargetable | TexCreate_FastVRAM);<br><br><span class="hljs-function">FLinearColor <span class="hljs-title">ClearColor</span><span class="hljs-params">(<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>)</span></span>;<br>OutputDesc.ClearValue = <span class="hljs-built_in">FClearValueBinding</span>(ClearColor);<br>&#125;<br><br>FRDGTextureRef OutputTexture = GraphBuilder.<span class="hljs-built_in">CreateTexture</span>(OutputDesc, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;LenDistortion Effect Output Texture&quot;</span>));<br><br>FLenDistortionCS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FLenDistortionCS::FParameters&gt;();<br><br>FIntPoint PassViewSize = SceneColor.ViewRect.<span class="hljs-built_in">Size</span>();<br><br>PassParameters-&gt;View = SceneView.ViewUniformBuffer;<br>PassParameters-&gt;RetroScaleFactor = CVarScaleFactor.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;LensDistortionK1 = CVarLenDistortionK<span class="hljs-number">1.</span><span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;LensDistortionK2 = CVarLenDistortionK<span class="hljs-number">2.</span><span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;VignetteStart = CVarVignetteStart.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;VignetteEnd = CVarVignetteEnd.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;VignettePower = CVarVignettePower.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;VignetteIntensity = CVarVignetteIntensity.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;ScanlineScale = CVarScanlineScale.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;ScanlineSpeed = CVarScanlineSpeed.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;ScanlineIntensity = CVarScanlineIntensity.<span class="hljs-built_in">GetValueOnRenderThread</span>();<br>PassParameters-&gt;OriginalSceneColor = SceneColor.Texture;<br>PassParameters-&gt;TVMaskTexture = TVMaskTextureRHI.<span class="hljs-built_in">IsValid</span>() ? TVMaskTextureRHI : GWhiteTexture-&gt;TextureRHI;<br>PassParameters-&gt;ScanLineTexture = ScanLineTextureRHI.<span class="hljs-built_in">IsValid</span>()? ScanLineTextureRHI : GWhiteTexture-&gt;TextureRHI;<br>PassParameters-&gt;SceneColorViewport = <span class="hljs-built_in">GetScreenPassTextureViewportParameters</span>(SceneColorViewport);<br>PassParameters-&gt;Output = GraphBuilder.<span class="hljs-built_in">CreateUAV</span>(<span class="hljs-built_in">FRDGTextureUAVDesc</span>(OutputTexture));<br><br>FIntVector GroupCount = FComputeShaderUtils::<span class="hljs-built_in">GetGroupCount</span>(PassViewSize, FComputeShaderUtils::kGolden2DGroupSize);<br><br>FComputeShaderUtils::<span class="hljs-built_in">AddPass</span>(<br>GraphBuilder,<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;LenDistorted Post Processing CS Shader %dx%d&quot;</span>, PassViewSize.X, PassViewSize.Y),<br>ComputeShader,<br>PassParameters,<br>GroupCount<br>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">FScreenPassTexture</span>(OutputTexture, SceneColor.ViewRect);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>值得一提的是，我们需要额外创建一张<strong>用于写入的输出纹理</strong>，而不能直接对输入的<code>SceneColor</code> 进行 UAV 写入。最方便的做法是以<code>SceneColor.Texture-&gt;Desc</code>为基础复制一份描述信息，保证分辨率、格式等属性一致；随后再对其做少量修改：为其添加<code>TexCreate_UAV</code> 标志，使其可被 Compute Shader 写入，同时移除<code>TexCreate_RenderTargetable</code> 和<code>TexCreate_FastVRAM</code>等与当前使用场景不匹配的标志，并设置合适的清除色。</p><p>最后返回这个新建的输出纹理即可，它会由RDG自动管理。</p><h3id="用developersettings获取外部纹理">用DeveloperSettings获取外部纹理</h3><p>至此，我们已经创建了一个自定义的<code>SceneViewExtension</code>。但由于 <code>SceneViewExtension</code>并不是 <code>UObject</code> 的子类，无法在 Unreal Editor中直接创建蓝图或暴露可编辑属性，那么该如何将<strong>编辑器中配置的纹理资源</strong> 传递给这个 SVE 呢？</p><p>一个相对简单且常用的解决方案是借助 <code>DeveloperSettings</code>类来维护这些全局资源。通过这种方式，我们可以在 <strong>项目设置（ProjectSettings）</strong> 的对应页面中直接指定所需的纹理或参数，而<code>SceneViewExtension</code> 则在运行时读取这些配置并加以使用。</p><p>因此，新建一个C++类，父类选择<code>DeveloperSettings</code>，并在类中声明两个<code>UTexture2D</code>变量：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UTexture2D</span>;<br><br><span class="hljs-built_in">UCLASS</span>(Config = RetroTV, DefaultConfig, meta=(DisplayName=<span class="hljs-string">&quot;RetroTV&quot;</span>))<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RETROTV_API</span> URetroTVSettings : <span class="hljs-keyword">public</span> UDeveloperSettings<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, Config, Category = <span class="hljs-string">&quot;Textures&quot;</span>)<br>TSoftObjectPtr&lt;UTexture2D&gt; TVMaskTexture;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, Config, Category = <span class="hljs-string">&quot;Textures&quot;</span>)<br>TSoftObjectPtr&lt;UTexture2D&gt; ScanLineTexture;<br><br><span class="hljs-built_in">URetroTVSettings</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>现在打开UE的项目设置，找到RetroTV标签，打开之后就能指定资源了。<img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/IMG-20260131211529221.png" class=""></p><h3 id="实例化自定义sve类">实例化自定义SVE类</h3><p>在<code>Subsystem</code>中实例化SVE类是比较推荐的做法。因此新建一个C++类，命名为<code>RetroTVSubsystem</code>，父类选择<code>UGameInstanceSubsystem</code>。它需要维护一个SVE类，并在这个子系统初始化的时候，用<code>UTexture2D</code>初始化SVE类中纹理资源。相关代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RETROTV_API</span> URetroTVSubsystem : <span class="hljs-keyword">public</span> UGameInstanceSubsystem<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(FSubsystemCollectionBase&amp; Collection)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Deinitialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>TSharedPtr&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">FRetroTVSceneViewExtension</span>, ESPMode::ThreadSafe&gt; CustomSceneViewExtension;<br><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>对应函数实现如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RetroTVSubsystem.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RetroTVSettings.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RetroTVSceneViewExtension.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">URetroTVSubsystem::Initialize</span><span class="hljs-params">(FSubsystemCollectionBase&amp; Collection)</span></span><br><span class="hljs-function"></span>&#123;<br>CustomSceneViewExtension = FSceneViewExtensions::<span class="hljs-built_in">NewExtension</span>&lt;FRetroTVSceneViewExtension&gt;();<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;SceneViewExtensionTemplate: Subsystem initialized &amp; SceneViewExtension created&quot;</span>));<br><br><span class="hljs-type">const</span> URetroTVSettings* Settings = <span class="hljs-built_in">GetDefault</span>&lt;URetroTVSettings&gt;();<br>UTexture2D* TVMaskTexturePtr = Settings ? Settings-&gt;TVMaskTexture.<span class="hljs-built_in">LoadSynchronous</span>() : <span class="hljs-literal">nullptr</span>;<br>UTexture2D* ScanLineTexturePtr = Settings ? Settings-&gt;ScanLineTexture.<span class="hljs-built_in">LoadSynchronous</span>() : <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">if</span> (!TVMaskTexturePtr)<br>&#123;<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Warning, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;RetroTV: TVMaskTexture not set or failed to load. (Project Settings -&gt; RetroTV)&quot;</span>));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!ScanLineTexturePtr)<br>&#123;<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Warning, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;RetroTV: ScanLineTexture not set or failed to load. (Project Settings -&gt; RetroTV)&quot;</span>));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>CustomSceneViewExtension-&gt;<span class="hljs-built_in">SetTVMaskTexture</span>(TVMaskTexturePtr);<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;RetroTV: TVMaskTexture set to %s&quot;</span>), *TVMaskTexturePtr-&gt;<span class="hljs-built_in">GetName</span>());<br><br>CustomSceneViewExtension-&gt;<span class="hljs-built_in">SetScanLineTexture</span>(ScanLineTexturePtr);<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;RetroTV: ScanLineTexture set to %s&quot;</span>), *ScanLineTexturePtr-&gt;<span class="hljs-built_in">GetName</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">URetroTVSubsystem::Deinitialize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#123;<br>CustomSceneViewExtension-&gt;IsActiveThisFrameFunctions.<span class="hljs-built_in">Empty</span>();<br><br>FSceneViewExtensionIsActiveFunctor IsActiveFunctor;<br><br>IsActiveFunctor.IsActiveFunction = [](<span class="hljs-type">const</span> ISceneViewExtension* SceneViewExtension, <span class="hljs-type">const</span> FSceneViewExtensionContext&amp; Context)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">TOptional</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-literal">false</span>);<br>&#125;;<br><br>CustomSceneViewExtension-&gt;IsActiveThisFrameFunctions.<span class="hljs-built_in">Add</span>(IsActiveFunctor);<br>&#125;<br><br>CustomSceneViewExtension.<span class="hljs-built_in">Reset</span>();<br>CustomSceneViewExtension = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 至此所有代码编辑完成。</p><h3 id="最终效果">最终效果</h3><p>点击模拟（第一次模拟可能会出现问题，大概率是因为资源还没有完全加载完毕），在控制台输入<code>r.RetroTV 1</code>即可启用这个后处理效果：<img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/03-%E7%94%A8SceneViewExtension%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/IMG-20260131212439161.png" class=""></p>]]></content>
    
    
    <categories>
      
      <category>虚幻引擎</category>
      
      <category>渲染依赖图</category>
      
      <category>SceneViewExtension</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
      <tag>渲染依赖图</tag>
      
      <tag>RDG</tag>
      
      <tag>SceneViewExtension</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚幻引擎RDG图形管线调用流程</title>
    <link href="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>这是我在学习 Unreal渲染依赖图（RDG）过程中的踩坑与总结笔记（二），本篇主要记录在虚幻引擎中调用图形管线的实践过程。</p><p>虚幻版本5.7</p><p>本篇主要介绍如何通过 <code>AddPass()</code> 调用图形管线，Unreal引擎的配置与上一篇相同。</p><h3 id="在-ue-中使用-rdg-构建图形管线">在 UE 中使用 RDG构建图形管线</h3><h4id="编写顶点和像素着色器的usf文件">编写顶点和像素着色器的usf文件</h4><p>在工程目录下的<code>Shaders</code>创建一个名为<code>GraphicsShader.usf</code>的文件，编写以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Public/Platform.ush&quot;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VS_INPUT</span><br>&#123;<br>    float2 Position : ATTRIBUTE0;<br>    float2 TexCoord : ATTRIBUTE1;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VS_OUTPUT</span><br>&#123;<br>    float4 Position : SV_POSITION;<br>    float2 TexCoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainVS</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    in VS_INPUT Input,</span></span><br><span class="hljs-params"><span class="hljs-function">    out VS_OUTPUT Output</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>    Output.Position = <span class="hljs-built_in">float4</span>(Input.Position, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    Output.TexCoord = Input.TexCoord;<br>&#125;<br><br><span class="hljs-type">float</span> BValue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainPS</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    in VS_OUTPUT PS_Input,</span></span><br><span class="hljs-params"><span class="hljs-function">    out float4 OutColor : SV_Target0</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>    OutColor = <span class="hljs-built_in">float4</span>(PS_Input.TexCoord.x, PS_Input.TexCoord.y, BValue, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>.usf</code> 文件中，顶点输入必须通过 <code>ATTRIBUTE</code>语义与顶点缓冲进行绑定。除系统语义外，着色器阶段之间只能使用<code>TEXCOORD</code> 和 <code>COLOR</code> 作为中间语义。</p><h4id="创建顶点和像素着色器的global-shader">创建顶点和像素着色器的GlobalShader</h4><p>接下来我们将回到上一篇中的<code>LearnRDGShader.cpp</code>，在此基础上继续完善代码。</p><p>在<code>LearnRDGShader.cpp</code>中添加以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> FTestVS : <span class="hljs-keyword">public</span> FGlobalShader<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DECLARE_GLOBAL_SHADER</span>(FTestVS);<br><span class="hljs-built_in">SHADER_USE_PARAMETER_STRUCT</span>(FTestVS, FGlobalShader);<br><br><span class="hljs-built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters, )<br><br><span class="hljs-built_in">END_SHADER_PARAMETER_STRUCT</span>()<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ShouldCompilePermutation</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_GLOBAL_SHADER</span>(FTestVS, <span class="hljs-string">&quot;/MyShaders/GraphicsShader.usf&quot;</span>, <span class="hljs-string">&quot;MainVS&quot;</span>, SF_Vertex);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> FTestPS : <span class="hljs-keyword">public</span> FGlobalShader<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DECLARE_GLOBAL_SHADER</span>(FTestPS);<br><span class="hljs-built_in">SHADER_USE_PARAMETER_STRUCT</span>(FTestPS, FGlobalShader);<br><br><span class="hljs-built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters,)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, BValue)<br><span class="hljs-built_in">RENDER_TARGET_BINDING_SLOTS</span>()<br><span class="hljs-built_in">END_SHADER_PARAMETER_STRUCT</span>()<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ShouldCompilePermutation</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_GLOBAL_SHADER</span>(FTestPS, <span class="hljs-string">&quot;/MyShaders/GraphicsShader.usf&quot;</span>, <span class="hljs-string">&quot;MainPS&quot;</span>, SF_Pixel);<br></code></pre></td></tr></table></figure><p>这段代码的作用是将 <code>.usf</code> 文件中定义的着色器注册为 Unreal引擎可识别和使用的全局着色器。</p><h4 id="使用frdgbuilder添加计算pass">使用FRDGBuilder添加计算Pass</h4><p>在<code>LearnRDGShader.h</code>中添加函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> LearnRDGShader<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTestGraphicsPass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, FRDGTextureRef RenderTarget, <span class="hljs-type">float</span> BValue)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的 <code>FRDGTextureRef</code>作为我们的渲染目标使用，本质上是一块存放在显存中的纹理缓冲区。</p><p>在<code>LearnRDGShader.cpp</code>中实现函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LearnRDGShader::AddTestGraphicsPass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, FRDGTextureRef RenderTarget, <span class="hljs-type">float</span> BValue)</span></span><br><span class="hljs-function"></span>&#123;<br>FGlobalShaderMap* ShaderMap =  <span class="hljs-built_in">GetGlobalShaderMap</span>(GMaxRHIFeatureLevel);<br><br><span class="hljs-function">TShaderMapRef&lt;FTestVS&gt; <span class="hljs-title">VertexShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><span class="hljs-function">TShaderMapRef&lt;FTestPS&gt; <span class="hljs-title">PixelShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><br>FTestPS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestPS::FParameters&gt;();<br>PassParameters-&gt;BValue = BValue;<br>PassParameters-&gt;RenderTargets[<span class="hljs-number">0</span>] = <span class="hljs-built_in">FRenderTargetBinding</span>(RenderTarget, ERenderTargetLoadAction::EClear);<br><br>GraphBuilder.<span class="hljs-built_in">AddPass</span>(<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;MyTestGraphicsPass&quot;</span>),<br>PassParameters,<br>ERDGPassFlags::Raster,<br>[\*Todo*\](FRHICommandList&amp; RHICmdList)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>和计算着色器相比，图形管线的配置会麻烦不少。我们需要依次配置图形管线的各个部分，比如顶点缓冲区、全局缓冲区，以及图形管线本身的各种选项。</p><p>接下来我们先来配置顶点缓冲区，整体流程可以分为以下几个步骤：</p><ol type="1"><li>在 GPU 侧创建顶点缓冲区；</li><li>在 CPU 侧声明并准备具体的顶点数据；</li><li>将 CPU 端的数据上传到刚刚创建的 GPU 顶点缓冲区中；</li><li>配置对应的 <code>FVertexDeclarationRHIRef</code>；</li><li>将其绑定到 <code>FGraphicsPipelineStateInitializer</code> 的<code>BoundShaderState.VertexDeclarationRHI</code> 中；</li><li>指定所需的缓冲区。</li></ol><p>相关代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LearnRDGShader::AddTestGraphicsPass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, FRDGTextureRef RenderTarget, <span class="hljs-type">float</span> BValue)</span></span><br><span class="hljs-function"></span>&#123;<br>FGlobalShaderMap* ShaderMap =  <span class="hljs-built_in">GetGlobalShaderMap</span>(GMaxRHIFeatureLevel);<br><br><span class="hljs-function">TShaderMapRef&lt;FTestVS&gt; <span class="hljs-title">VertexShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><span class="hljs-function">TShaderMapRef&lt;FTestPS&gt; <span class="hljs-title">PixelShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><br>FTestPS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestPS::FParameters&gt;();<br>PassParameters-&gt;BValue = BValue;<br>PassParameters-&gt;RenderTargets[<span class="hljs-number">0</span>] = <span class="hljs-built_in">FRenderTargetBinding</span>(RenderTarget, ERenderTargetLoadAction::EClear);<br><br><span class="hljs-comment">//Start Edit</span><br><span class="hljs-keyword">constexpr</span> uint32 NumVertices = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">constexpr</span> uint32 NumIndices = <span class="hljs-number">6</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VS_INPUT</span><br>&#123;<br>FVector2f Position;<br>FVector2f TexCoord;<br>&#125;;<br><br>FRDGBufferRef VertexBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateUploadDesc</span>(<span class="hljs-built_in">sizeof</span>(VS_INPUT), NumVertices),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyVertexBuffer&quot;</span>));<br><br><span class="hljs-function">FRDGUploadData&lt;VS_INPUT&gt; <span class="hljs-title">VSInputData</span><span class="hljs-params">(GraphBuilder, <span class="hljs-number">4</span>)</span></span>;<br>VSInputData[<span class="hljs-number">0</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">-1.0f</span>,  <span class="hljs-number">1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">1</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>,  <span class="hljs-number">1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">2</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">3</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>) &#125;;<br><br>GraphBuilder.<span class="hljs-built_in">QueueBufferUpload</span>(VertexBuffer, VSInputData, ERDGInitialDataFlags::NoCopy);<br><br>FRDGBufferRef IndexBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateUploadDesc</span>(<span class="hljs-built_in">sizeof</span>(uint32), NumIndices),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyIndexBuffer&quot;</span>));<br><br><span class="hljs-function">FRDGUploadData&lt;int32&gt; <span class="hljs-title">Indices</span><span class="hljs-params">(GraphBuilder, <span class="hljs-number">6</span>)</span></span>;<br>Indices[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>Indices[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>Indices[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>Indices[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>Indices[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>;<br>Indices[<span class="hljs-number">5</span>] = <span class="hljs-number">3</span>;<br><br>GraphBuilder.<span class="hljs-built_in">QueueBufferUpload</span>(IndexBuffer, Indices, ERDGInitialDataFlags::NoCopy);<br><br>uint16 Stride = <span class="hljs-built_in">sizeof</span>(VS_INPUT);<br>FVertexDeclarationElementList Elements;<br>Elements.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">FVertexElement</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">STRUCT_OFFSET</span>(VS_INPUT, Position), VET_Float2, <span class="hljs-number">0</span>, Stride));<br>Elements.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">FVertexElement</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">STRUCT_OFFSET</span>(VS_INPUT, TexCoord), VET_Float2, <span class="hljs-number">1</span>, Stride));<br>FVertexDeclarationRHIRef VertexDeclarationRHI = PipelineStateCache::<span class="hljs-built_in">GetOrCreateVertexDeclaration</span>(Elements);<br><br><span class="hljs-comment">//End Edit</span><br><br>GraphBuilder.<span class="hljs-built_in">AddPass</span>(<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;MyTestGraphicsPass&quot;</span>),<br>PassParameters,<br>ERDGPassFlags::Raster,<br>[VertexDeclarationRHI](FRHICommandList&amp; RHICmdList)<br>&#123;<br><span class="hljs-comment">//Start Edit</span><br>FGraphicsPipelineStateInitializer GraphicsPSOInit;<br>GraphicsPSOInit.BoundShaderState.VertexShaderRHI = VertexShader.<span class="hljs-built_in">GetVertexShader</span>();<br><span class="hljs-built_in">SetGraphicsPipelineState</span>(RHICmdList, GraphicsPSOInit, <span class="hljs-number">0</span>);<br><br>RHICmdList.<span class="hljs-built_in">SetStreamSource</span>(<span class="hljs-number">0</span>, VertexBuffer-&gt;<span class="hljs-built_in">GetRHI</span>(), <span class="hljs-number">0</span>);<br>RHICmdList.<span class="hljs-built_in">DrawIndexedPrimitive</span>(IndexBuffer-&gt;<span class="hljs-built_in">GetRHI</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//End Edit</span><br>&#125;<br>);<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>我们通过 <code>FRDGBuilder</code> 的成员函数<code>CreateBuffer()</code> 来创建缓冲区，随后调用<code>QueueBufferUpload()</code> 将 CPU 端的数据上传到顶点缓冲区中。</p><p>索引缓冲区的处理方式与此相同，按照同样的流程进行创建和数据上传即可。</p><p>配置管线的各种选项，包括视口大小、深度模板测试、混合方式、剔除方式、图元类型等等，完整代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LearnRDGShader::AddTestGraphicsPass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, FRDGTextureRef RenderTarget, <span class="hljs-type">float</span> BValue)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">constexpr</span> uint32 NumVertices = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">constexpr</span> uint32 NumIndices = <span class="hljs-number">6</span>;<br><span class="hljs-function"><span class="hljs-type">const</span> FIntRect <span class="hljs-title">ViewRect</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, RenderTarget-&gt;Desc.Extent.X, RenderTarget-&gt;Desc.Extent.Y)</span></span>;<br><br><br>FGlobalShaderMap* ShaderMap =  <span class="hljs-built_in">GetGlobalShaderMap</span>(GMaxRHIFeatureLevel);<br><br><span class="hljs-function">TShaderMapRef&lt;FTestVS&gt; <span class="hljs-title">VertexShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><span class="hljs-function">TShaderMapRef&lt;FTestPS&gt; <span class="hljs-title">PixelShader</span><span class="hljs-params">(ShaderMap)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VS_INPUT</span><br>&#123;<br>FVector2f Position;<br>FVector2f TexCoord;<br>&#125;;<br><br>FRDGBufferRef VertexBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateUploadDesc</span>(<span class="hljs-built_in">sizeof</span>(VS_INPUT), NumVertices),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyVertexBuffer&quot;</span>));<br><br><span class="hljs-function">FRDGUploadData&lt;VS_INPUT&gt; <span class="hljs-title">VSInputData</span><span class="hljs-params">(GraphBuilder, <span class="hljs-number">4</span>)</span></span>;<br>VSInputData[<span class="hljs-number">0</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">-1.0f</span>,  <span class="hljs-number">1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">1</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>,  <span class="hljs-number">1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">2</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">-1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>) &#125;;<br>VSInputData[<span class="hljs-number">3</span>] = &#123; <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>), <span class="hljs-built_in">FVector2f</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>) &#125;;<br><br>GraphBuilder.<span class="hljs-built_in">QueueBufferUpload</span>(VertexBuffer, VSInputData, ERDGInitialDataFlags::NoCopy);<br><br>FRDGBufferRef IndexBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateUploadDesc</span>(<span class="hljs-built_in">sizeof</span>(uint32), NumIndices),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyIndexBuffer&quot;</span>));<br><br><span class="hljs-function">FRDGUploadData&lt;int32&gt; <span class="hljs-title">Indices</span><span class="hljs-params">(GraphBuilder, <span class="hljs-number">6</span>)</span></span>;<br>Indices[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>Indices[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>Indices[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>Indices[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>Indices[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>;<br>Indices[<span class="hljs-number">5</span>] = <span class="hljs-number">3</span>;<br><br>GraphBuilder.<span class="hljs-built_in">QueueBufferUpload</span>(IndexBuffer, Indices, ERDGInitialDataFlags::NoCopy);<br><br>FTestPS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestPS::FParameters&gt;();<br>PassParameters-&gt;BValue = BValue;<br>PassParameters-&gt;RenderTargets[<span class="hljs-number">0</span>] = <span class="hljs-built_in">FRenderTargetBinding</span>(RenderTarget, ERenderTargetLoadAction::EClear);<br><br>uint16 Stride = <span class="hljs-built_in">sizeof</span>(VS_INPUT);<br>FVertexDeclarationElementList Elements;<br>Elements.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">FVertexElement</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">STRUCT_OFFSET</span>(VS_INPUT, Position), VET_Float2, <span class="hljs-number">0</span>, Stride));<br>Elements.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">FVertexElement</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">STRUCT_OFFSET</span>(VS_INPUT, TexCoord), VET_Float2, <span class="hljs-number">1</span>, Stride));<br>FVertexDeclarationRHIRef VertexDeclarationRHI = PipelineStateCache::<span class="hljs-built_in">GetOrCreateVertexDeclaration</span>(Elements);<br><br>GraphBuilder.<span class="hljs-built_in">AddPass</span>(<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;MyTestGraphicsPass&quot;</span>),<br>PassParameters,<br>ERDGPassFlags::Raster,<br>[VertexShader, PixelShader, PassParameters, VertexBuffer, IndexBuffer, ViewRect, VertexDeclarationRHI](FRHICommandList&amp; RHICmdList)<br>&#123;<br>RHICmdList.<span class="hljs-built_in">SetViewport</span>(ViewRect.Min.X, ViewRect.Min.Y, <span class="hljs-number">0.0f</span>, ViewRect.Max.X, ViewRect.Max.Y, <span class="hljs-number">1.0f</span>);<br><br>FGraphicsPipelineStateInitializer GraphicsPSOInit;<br>RHICmdList.<span class="hljs-built_in">ApplyCachedRenderTargets</span>(GraphicsPSOInit);<br>GraphicsPSOInit.BlendState = TStaticBlendState&lt;&gt;::<span class="hljs-built_in">GetRHI</span>();<br>GraphicsPSOInit.RasterizerState = TStaticRasterizerState&lt;&gt;::<span class="hljs-built_in">GetRHI</span>();<br>GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState&lt;<span class="hljs-literal">false</span>, CF_Always&gt;::<span class="hljs-built_in">GetRHI</span>();<br>GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = VertexDeclarationRHI;<br>GraphicsPSOInit.BoundShaderState.VertexShaderRHI = VertexShader.<span class="hljs-built_in">GetVertexShader</span>();<br>GraphicsPSOInit.BoundShaderState.PixelShaderRHI = PixelShader.<span class="hljs-built_in">GetPixelShader</span>();<br>GraphicsPSOInit.PrimitiveType = PT_TriangleList;<br><span class="hljs-built_in">SetGraphicsPipelineState</span>(RHICmdList, GraphicsPSOInit, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">SetShaderParameters</span>(RHICmdList, PixelShader, PixelShader.<span class="hljs-built_in">GetPixelShader</span>(), *PassParameters);<br><br>RHICmdList.<span class="hljs-built_in">SetStreamSource</span>(<span class="hljs-number">0</span>, VertexBuffer-&gt;<span class="hljs-built_in">GetRHI</span>(), <span class="hljs-number">0</span>);<br><br>RHICmdList.<span class="hljs-built_in">DrawIndexedPrimitive</span>(IndexBuffer-&gt;<span class="hljs-built_in">GetRHI</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>&#125;<br>);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="在actor中的beginplay中调用">在Actor中的BeginPlay()中调用</h3><p>新建一个 C++类，父类选择 <code>Actor</code>，并命名为 <code>GraphicsRDGHelper</code>。<br />随后在 <code>GraphicsRDGHelper</code> 类的 <code>BeginPlay()</code> 生命周期函数中，调用前面实现的用于向RDG 添加计算 Pass 的函数。</p><p><code>GraphicsRDGHelper.h</code>的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GraphicsRDGHelper.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> AGraphicsRDGHelper : <span class="hljs-keyword">public</span> AActor<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Sets default values for this actor&#x27;s properties</span><br><span class="hljs-built_in">AGraphicsRDGHelper</span>();<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="hljs-string">&quot;TestShader&quot;</span>)<br>TObjectPtr&lt;UTextureRenderTarget2D&gt; GraphicsRDGRenderTarget;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="hljs-string">&quot;TestShader&quot;</span>)<br><span class="hljs-type">float</span> BValue = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Called every frame</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTestGraphicsPass</span><span class="hljs-params">(UTextureRenderTarget2D* RenderTarget2D, <span class="hljs-type">float</span> BChannelValue)</span> <span class="hljs-type">const</span></span>;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><code>GraphicsRDGHelper.cpp</code>的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GraphicsRDGHelper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphBuilder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Engine/TextureRenderTarget2D.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LearnRDGShader.h&quot;</span></span><br><span class="hljs-comment">// Sets default values</span><br>AGraphicsRDGHelper::<span class="hljs-built_in">AGraphicsRDGHelper</span>()<br>&#123;<br> <span class="hljs-comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span><br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AGraphicsRDGHelper::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">BeginPlay</span>();<br><br><span class="hljs-built_in">check</span>(GEngine != <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsValid</span>(GraphicsRDGRenderTarget))<br><span class="hljs-built_in">AddTestGraphicsPass</span>(GraphicsRDGRenderTarget.<span class="hljs-built_in">Get</span>(), BValue);<br>&#125;<br><br><span class="hljs-comment">// Called every frame</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AGraphicsRDGHelper::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">Tick</span>(DeltaTime);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AGraphicsRDGHelper::AddTestGraphicsPass</span><span class="hljs-params">(UTextureRenderTarget2D* RenderTarget2D, <span class="hljs-type">float</span> BChannelValue)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AddTestGraphicsPass&quot;</span>));<br><br>FTextureResource* RenderResource = RenderTarget2D-&gt;<span class="hljs-built_in">GetResource</span>();<br><br><span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(AddTestGraphicsPass)(<br>[RenderResource, BChannelValue](FRHICommandListImmediate&amp; RHICmdList)<br>&#123;<br>FRDGBuilder <span class="hljs-built_in">GraphBuilder</span>(RHICmdList);<br><br>FTextureRHIRef TextureRHI = RenderResource-&gt;<span class="hljs-built_in">GetTextureRHI</span>();<br><br>FRDGTextureRef RDGTexture =<br>GraphBuilder.<span class="hljs-built_in">RegisterExternalTexture</span>(<br><span class="hljs-built_in">CreateRenderTarget</span>(TextureRHI, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyRT2D_External&quot;</span>))<br>);<br><br>LearnRDGShader::<span class="hljs-built_in">AddTestGraphicsPass</span>(GraphBuilder, RDGTexture, BChannelValue);<br><br>GraphBuilder.<span class="hljs-built_in">Execute</span>();<br>&#125;<br>);<br><br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AddTestGraphicsPassFinish&quot;</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="在编辑器中创建蓝图">在编辑器中创建蓝图</h3><p>接下来为刚刚编写的 C++ 类创建对应的 UE 蓝图，并新建一个<code>Material</code> 和一个 <code>RenderTarget</code>。将该<code>RenderTarget</code> 连接到 <code>Material</code> 的 BaseColor（基础色）输入上，然后将该 <code>Material</code> 指定给对应的 UE蓝图进行使用。 <img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260127165041585.png" class=""></p><img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260127165144256.png" class=""><p>点击模拟，可以看到颜色已经正确地输入到纹理 <img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/02-RDG%20%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260127165226753.png" class=""></p><h3 id="addfullscreenpass">AddFullScreenPass</h3><p>对于仅包含全屏两个三角形的顶点数据，可以直接使用 Unreal 提供的<code>AddFullScreenPass</code> 辅助函数来简化代码实现，具体用法可以参考UE的相关源码实现。需要注意的是，在使用该辅助函数时，像素着色器在通常情况下只能接收一个<code>float4</code> 类型的“位置”输入。</p><p>一个简单的例子： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Public/Platform.ush&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Private/Common.ush&quot;</span></span><br><br><span class="hljs-type">float</span> BValue;<br>float2 TargetSize;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FullscreenPS</span><span class="hljs-params">(float4 InPosition : SV_POSITION,  out float4 OutColor : SV_Target0)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 UV = InPosition.xy / TargetSize;<br>    OutColor = <span class="hljs-built_in">float4</span>(UV.x, UV.y, BValue, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>需要注意的是，与 GLSL 中的用法不同，这里的 <code>SV_POSITION</code>表示的是屏幕空间下的像素位置，而非归一化后的 <code>[-1, 1]</code> NDC坐标。</p>]]></content>
    
    
    <categories>
      
      <category>虚幻引擎</category>
      
      <category>渲染依赖图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
      <tag>渲染依赖图</tag>
      
      <tag>RDG</tag>
      
      <tag>图形管线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚幻引擎RDG计算管线调用流程</title>
    <link href="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>这是我在学习 Unreal渲染依赖图（RDG）过程中的踩坑与总结笔记（一），本篇主要记录在虚幻引擎中调用计算着色器的实践过程。</p><p>Unreal版本为5.7。</p><h3 id="配置unreal工程">配置Unreal工程</h3><h4 id="创建unreal工程">创建Unreal工程</h4><p>创建一个空白C++虚幻工程，将项目名称设置为<code>LearnRDG</code>。<img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260124194958682.png" class=""></p><h4 id="配置uproject">配置uproject</h4><p>打开工程文件夹下的<code>LearnRDG.uproject</code>，将<code>Modules</code>内的<code>LoadingPharse</code>从<code>Default</code>修改为<code>PostConfigInit</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-string">&quot;Modules&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;LearnRDG&quot;</span>,<br><span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Runtime&quot;</span>,<br><span class="hljs-comment">// &quot;LoadingPharse&quot;: &quot;Default&quot;,</span><br><span class="hljs-string">&quot;LoadingPhase&quot;</span>: <span class="hljs-string">&quot;PostConfigInit&quot;</span>,<br><span class="hljs-string">&quot;AdditionalDependencies&quot;</span>: [<br><span class="hljs-string">&quot;Engine&quot;</span><br>]<br>&#125;<br>]<br></code></pre></td></tr></table></figure><h4 id="修改learnrdg.build.cs">修改LearnRDG.Build.cs</h4><p>打开<code>LearnRDG.Build.cs</code>，添加<code>RHI</code>、<code>RenderCore</code>、<code>Projects</code>依赖。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">using</span> UnrealBuildTool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LearnRDG</span> : <span class="hljs-title">ModuleRules</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LearnRDG</span>(<span class="hljs-params">ReadOnlyTargetRules Target</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">Target</span>)</span><br>&#123;<br>PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br><br>PublicDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;Core&quot;</span>,                          <span class="hljs-string">&quot;CoreUObject&quot;</span>, <span class="hljs-string">&quot;Engine&quot;</span>, <span class="hljs-string">&quot;InputCore&quot;</span> &#125;);<br><br>PrivateDependencyModuleNames.AddRange(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;RHI&quot;</span>,                          <span class="hljs-string">&quot;RenderCore&quot;</span>, <span class="hljs-string">&quot;Projects&quot;</span> &#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改learnrdg.cpp">修改LearnRDG.cpp</h4><p>官方文档中提到，Unreal 的着色器文件（<code>.usf</code> /<code>.ush</code>）通常存放在 <code>Engine/Shaders</code> 和<code>Engine/Plugins</code> 目录下。</p><p>为了便于管理，我们希望将自定义着色器放置在工程目录中，因此首先在工程根目录下创建一个<code>Shaders</code> 文件夹。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LearnRDG<br>|- Content<br>|- Sources<br>|- Shaders <span class="hljs-comment">// Shaders文件夹和Content|Sources处于同一目录下</span><br></code></pre></td></tr></table></figure></p><p>随后打开<code>LearnRDG.cpp</code>文件，将内容替换为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LearnRDG.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Modules/ModuleManager.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Misc/Paths.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ShaderCore.h&quot;</span> </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FLearnRDGGameModule</span> : <span class="hljs-keyword">public</span> FDefaultGameModuleImpl<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">StartupModule</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> FString ShaderDir = FPaths::<span class="hljs-built_in">Combine</span>(FPaths::<span class="hljs-built_in">ProjectDir</span>(), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Shaders&quot;</span>));<br><span class="hljs-built_in">AddShaderSourceDirectoryMapping</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/MyShaders&quot;</span>), ShaderDir);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShutdownModule</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_PRIMARY_GAME_MODULE</span>(FLearnRDGGameModule, LearnRDG, <span class="hljs-string">&quot;LearnRDG&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>在 <code>FLearnRDGGameModule</code> 的 <code>StartupModule()</code>中，通过相关代码构建虚拟路径映射。完成映射后，即可使用<strong><code>/MyShaders</code></strong> 来指代工程目录下的<strong><code>/Shaders</code></strong>文件夹，从而像使用引擎内置着色器路径一样引用自定义着色器。</p><p><strong>关闭虚幻编辑器，编译Visual Studio工程。</strong>一定要关闭编辑器后再编译，不然会遇到许多莫名其妙的问题（后续每次编译都需要先关闭虚幻编译器）。</p><h3 id="在-ue-中使用-rdg-构建计算管线">在 UE 中使用 RDG构建计算管线</h3><h4 id="编写计算着色器的usf文件">编写计算着色器的usf文件</h4><p>在工程目录下的<code>Shaders</code>创建一个名为<code>ComputeShader.usf</code>的文件，编写以下代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/Engine/Public/Platform.ush&quot;</span></span><br><br><span class="hljs-type">float</span> Scale;<br><span class="hljs-type">float</span> Translate;<br>  <br>StructuredBuffer&lt;<span class="hljs-type">float</span>&gt; InputBuffer;<br>RWStructuredBuffer&lt;<span class="hljs-type">float</span>&gt; OutputBuffer;<br><br>[<span class="hljs-built_in">numthreads</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainCS</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    uint3 DispatchThreadId : SV_DispatchThreadID,</span></span><br><span class="hljs-params"><span class="hljs-function">    uint GroupIndex : SV_GroupIndex)</span></span><br><span class="hljs-function"></span>&#123;<br>    OutputBuffer[DispatchThreadId.x] = InputBuffer[DispatchThreadId.x] * Scale + Translate;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>（示例计算着色器来自：<ahref="https://sirenri2001.github.io/2025-02-05-unreal-shader-tutorial-(Chinese)/">UnrealShader Tutorial - Chinese Ver. | SirEnri’s Homepage</a>）</p><h4 id="创建计算着色器的global-shader">创建计算着色器的GlobalShader</h4><p>打开UE编辑器，选择 工具-&gt;新建C++文件，父类选择<strong>无</strong>，命名为<code>LearnRDGShader</code>。<img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260124203441757.png" class=""></p><p>删除<code>LearnRDGShader.h</code>中<code>#include "CoreMinimal.h"</code>以下的所有代码，删除<code>LearnRDGShader.cpp</code>中的所有代码。</p><p>在<code>LearnRDGShader.cpp</code>中编写以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LearnRDGShader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GlobalShader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphBuilder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ShaderParameterStruct.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphDefinitions.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphUtils.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RHIGPUReadback.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ScreenPass.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PixelShaderUtils.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> FTestCS : <span class="hljs-keyword">public</span> FGlobalShader<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DECLARE_GLOBAL_SHADER</span>(FTestCS);<br><span class="hljs-built_in">SHADER_USE_PARAMETER_STRUCT</span>(FTestCS, FGlobalShader);<br><br><span class="hljs-built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters, )<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, Scale)<br><span class="hljs-built_in">SHADER_PARAMETER</span>(<span class="hljs-type">float</span>, Translate)<br><span class="hljs-built_in">SHADER_PARAMETER_RDG_BUFFER_SRV</span>(StructuredBuffer&lt;<span class="hljs-type">float</span>&gt;, InputBuffer)<br><span class="hljs-built_in">SHADER_PARAMETER_RDG_BUFFER_UAV</span>(RWStructuredBuffer&lt;<span class="hljs-type">float</span>&gt;, OutputBuffer)<br><span class="hljs-built_in">END_SHADER_PARAMETER_STRUCT</span>()<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">ShouldCompilePermutation</span><span class="hljs-params">(<span class="hljs-type">const</span> FGlobalShaderPermutationParameters&amp; Parameters)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-built_in">IMPLEMENT_GLOBAL_SHADER</span>(FTestCS, <span class="hljs-string">&quot;/MyShaders/ComputeShader.usf&quot;</span>, <span class="hljs-string">&quot;MainCS&quot;</span>, SF_Compute);<br></code></pre></td></tr></table></figure><p>着色器类的声明参考UE源码，<code>BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )</code>内部的宏定义需要与<strong>HLSL源文件中的着色器输入</strong>一一对应。</p><p>随后调用<code>IMPLEMENT_GLOBAL_SHADER</code>，把 <code>.usf</code>里的计算着色器入口函数，注册成 Unreal可识别、可编译、可使用的全局着色器类型。</p><p>EPIC官方文档：<ahref="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/render-dependency-graph-in-unreal-engine">虚幻引擎中的渲染依赖图| 虚幻引擎 5.7 文档 | Epic Developer Community</a></p><h4 id="使用-frdgbuilder-添加计算-pass">使用 FRDGBuilder 添加计算Pass</h4><p>在<code>LearnRDGShader.h</code>添加函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> LearnRDGShader<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span> </span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>FRDGBuilder</code>是UE的RDG构建器，可以通过这个构建在渲染图中添加计算通道。<code>Scale</code>和<code>Translate</code>用于配置<code>Hlsl</code>中的参数。<code>FRHIGPUBufferReadback</code>用于回读计算着色器的输出结果到CPU。</p><p>在<code>LearnRDGShader.cpp</code>中实现函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>首先获取之前注册的计算着色器: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Start Edit</span><br><span class="hljs-function">TShaderMapRef&lt;FTestCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GetGlobalShaderMap(GMaxRHIFeatureLevel))</span></span>;<br><span class="hljs-comment">//End Edit</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>随后需要配置计算着色器的参数，包括两个 <code>float</code>类型的标量参数、一个作为输入的 <code>SRV</code>缓冲区，以及一个作为输出的 <code>UAV</code> 缓冲区。</p><p>这些参数通过 <code>FTestCS::FParameters</code>结构体进行描述，并在创建 Pass时将对应的资源与数值绑定到该结构体实例上。</p><p>现在配置<code>float</code>类型的标量参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">TShaderMapRef&lt;FTestCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GetGlobalShaderMap(GMaxRHIFeatureLevel))</span></span>;<br><span class="hljs-comment">//Start Edit</span><br>FTestCS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestCS::FParameters&gt;();<br>PassParameters-&gt;Scale = Scale;<br>PassParameters-&gt;Translate = Translate;<br><span class="hljs-comment">//End Edit</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>配置缓冲区稍微复杂，参考UE官方文档和源码，配置步骤如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">TShaderMapRef&lt;FTestCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GetGlobalShaderMap(GMaxRHIFeatureLevel))</span></span>;<br><br>FTestCS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestCS::FParameters&gt;();<br>PassParameters-&gt;Scale = Scale;<br>PassParameters-&gt;Translate = Translate;<br><br><span class="hljs-comment">//Start Edit</span><br><span class="hljs-keyword">constexpr</span> uint32 BufferElementNum = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">constexpr</span> uint32 BufferSize = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * BufferElementNum;<br><br>TArray&lt;<span class="hljs-type">float</span>&gt; InitialData; <span class="hljs-comment">//随便创建一些初始数据</span><br>InitialData.<span class="hljs-built_in">Init</span>(<span class="hljs-number">10.0f</span>, BufferElementNum);<br><br>FRDGBufferRef InRDGBuffer = <span class="hljs-built_in">CreateStructuredBuffer</span>(<br>GraphBuilder, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;TestCS.InRDGBuffer&quot;</span>), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), BufferElementNum,<br>InitialData.<span class="hljs-built_in">GetData</span>(), BufferSize<br>);<br><br>FRDGBufferSRVRef InSRV = GraphBuilder.<span class="hljs-built_in">CreateSRV</span>(InRDGBuffer);<br><br>FRDGBufferRef OutRDGBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateStructuredDesc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), BufferElementNum),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;TestCS.OutRDGBuffer&quot;</span>)<br>);<br>FRDGBufferUAVRef OutUAV = GraphBuilder.<span class="hljs-built_in">CreateUAV</span>(OutRDGBuffer);<br><br>PassParameters-&gt;InputBuffer = InSRV;<br>PassParameters-&gt;OutputBuffer = OutUAV;<br><span class="hljs-comment">//End Edit</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>由于需要在创建计算 Pass 之前从 CPU 侧初始化 GPU 缓冲区数据，这里使用UE 提供的辅助函数 <code>CreateStructuredBuffer</code> 来创建输入缓冲区<code>InRDGBuffer</code>。该函数会负责创建 RDGBuffer，并将初始数据上传至 GPU。</p><p>对于输出缓冲区，由于不需要 CPU 侧提供初始数据，直接通过<code>FRDGBuilder</code> 的成员函数 <code>CreateBuffer</code>创建即可（实际上，<code>CreateStructuredBuffer</code>的内部实现同样是基于 <code>CreateBuffer</code> 创建临时缓冲区）。</p><p>需要注意的是，在创建 <code>FRDGBufferRef</code>之后，还需要分别创建对应的 <code>FRDGBufferSRVRef</code> 和<code>FRDGBufferUAVRef</code> 才能在着色器中进行访问。这一设计与 Vulkan中 <code>VkBuffer</code> 和 <code>VkBufferView</code>的关系类似：前者表示资源本体，后者则描述了资源的具体访问方式。</p><p>随后添加计算Pass并回读数据 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestShader::AddTestComputePass</span><span class="hljs-params">(FRDGBuilder&amp; GraphBuilder, <span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate, FRHIGPUBufferReadback* Readback)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">TShaderMapRef&lt;FTestCS&gt; <span class="hljs-title">ComputeShader</span><span class="hljs-params">(GetGlobalShaderMap(GMaxRHIFeatureLevel))</span></span>;<br><br>FTestCS::FParameters* PassParameters = GraphBuilder.<span class="hljs-built_in">AllocParameters</span>&lt;FTestCS::FParameters&gt;();<br>PassParameters-&gt;Scale = Scale;<br>PassParameters-&gt;Translate = Translate;<br><br><span class="hljs-keyword">constexpr</span> uint32 BufferElementNum = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">constexpr</span> uint32 BufferSize = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * BufferElementNum;<br><br>TArray&lt;<span class="hljs-type">float</span>&gt; InitialData; <span class="hljs-comment">//随便创建一些初始数据</span><br>InitialData.<span class="hljs-built_in">Init</span>(<span class="hljs-number">10.0f</span>, BufferElementNum);<br><br>FRDGBufferRef InRDGBuffer = <span class="hljs-built_in">CreateStructuredBuffer</span>(<br>GraphBuilder, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;TestCS.InRDGBuffer&quot;</span>), <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), BufferElementNum,<br>InitialData.<span class="hljs-built_in">GetData</span>(), BufferSize<br>);<br><br>FRDGBufferSRVRef InSRV = GraphBuilder.<span class="hljs-built_in">CreateSRV</span>(InRDGBuffer);<br><br>FRDGBufferRef OutRDGBuffer = GraphBuilder.<span class="hljs-built_in">CreateBuffer</span>(<br>FRDGBufferDesc::<span class="hljs-built_in">CreateStructuredDesc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), BufferElementNum),<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;TestCS.OutRDGBuffer&quot;</span>)<br>);<br>FRDGBufferUAVRef OutUAV = GraphBuilder.<span class="hljs-built_in">CreateUAV</span>(OutRDGBuffer);<br><br>PassParameters-&gt;InputBuffer = InSRV;<br>PassParameters-&gt;OutputBuffer = OutUAV;<br><span class="hljs-comment">//Start Edit</span><br>GraphBuilder.<span class="hljs-built_in">AddPass</span>(<br><span class="hljs-built_in">RDG_EVENT_NAME</span>(<span class="hljs-string">&quot;MyAddCS&quot;</span>),<br>PassParameters,<br>ERDGPassFlags::Compute,<br>[PassParameters, ComputeShader, OutRDGBuffer, Readback](FRHICommandList&amp; RHICmdList)<br>&#123;<br>FComputeShaderUtils::<span class="hljs-built_in">Dispatch</span>(RHICmdList, ComputeShader, *PassParameters, <span class="hljs-built_in">FIntVector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>&#125;<br>);<br><br><span class="hljs-built_in">AddEnqueueCopyPass</span>(GraphBuilder, Readback, OutRDGBuffer, BufferSize);<br><span class="hljs-comment">//End Edit</span><br>&#125;<br></code></pre></td></tr></table></figure> 通过<code>FRDGBuilder</code> 的成员函数 <code>AddPass</code> 向 Render Graph中添加一个计算 Pass，并在传入的 lambda 函数中定义该 Pass的执行逻辑。</p><p>从使用方式上看，这一过程与 Vulkan 中通过 <code>vkCmd</code>系列函数向命令缓冲区提交操作较为相似，</p><p>最后，通过 UE 提供的辅助函数 <code>AddEnqueueCopyPass</code>将计算结果回读到 CPU。需要注意的是，数据回读必须通过单独的 Pass来完成，而不能直接在前面计算 Pass 的 lambda 函数中进行。</p><p>这是因为在 RDG 的构建阶段，Pass 仅用于描述执行逻辑，此时相关计算 Pass可能尚未执行完成，资源依赖和状态尚未满足；只有通过额外的拷贝Pass，才能确保在计算结果生成之后再进行数据回读。</p><h3 id="在-actor-的-beginplay-中调用">在 Actor 的 BeginPlay()中调用</h3><p>新建一个 C++ 类，父类选择 <code>Actor</code>，并命名为<code>ComputeRDGHelper</code>。 随后在 <code>ComputeRDGHelper</code>类的 <code>BeginPlay()</code> 生命周期函数中，调用前面实现的用于向 RDG添加计算 Pass 的函数。</p><p><code>ComputeRDGHelper.h</code>的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RHIGPUReadback.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ComputeRDGHelper.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEARNRDG_API</span> AComputeRDGHelper : <span class="hljs-keyword">public</span> AActor<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Sets default values for this actor&#x27;s properties</span><br><span class="hljs-built_in">AComputeRDGHelper</span>();<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="hljs-string">&quot;TestShader&quot;</span>)<br><span class="hljs-type">float</span> ScaleValue = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="hljs-string">&quot;TestShader&quot;</span>)<br><span class="hljs-type">float</span> TranslateValue = <span class="hljs-number">2.0f</span>;<br><br>TSharedPtr&lt;FRHIGPUBufferReadback, ESPMode::ThreadSafe&gt; Readback;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Called every frame</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTestComputePass</span><span class="hljs-params">(<span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><code>ComputeRDGHelper.cpp</code>的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ComputeRDGHelper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RenderGraphBuilder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LeranRDGShader.h&quot;</span></span><br><br><span class="hljs-comment">// Sets default values</span><br>AComputeRDGHelper::<span class="hljs-built_in">AComputeRDGHelper</span>()<br>&#123;<br> <span class="hljs-comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span><br>PrimaryActorTick.bCanEverTick = <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AComputeRDGHelper::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">BeginPlay</span>();<br><br><span class="hljs-built_in">check</span>(GEngine != <span class="hljs-literal">nullptr</span>);<br><br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;BeginPlay()!&quot;</span>));<br><br>Readback = <span class="hljs-built_in">MakeShared</span>&lt;FRHIGPUBufferReadback&gt;(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyAddReadback&quot;</span>));<br><br><span class="hljs-built_in">AddTestComputePass</span>(ScaleValue, TranslateValue);<br>&#125;<br><br><span class="hljs-comment">// Called every frame</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AComputeRDGHelper::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">Tick</span>(DeltaTime);<br><br>    <span class="hljs-keyword">if</span> (!Readback.<span class="hljs-built_in">IsValid</span>())<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (!Readback-&gt;<span class="hljs-built_in">IsReady</span>())<br>        <span class="hljs-keyword">return</span>;<br><br>    TSharedPtr&lt;FRHIGPUBufferReadback, ESPMode::ThreadSafe&gt; Local = Readback;<br>    Readback.<span class="hljs-built_in">Reset</span>();<br><br>    <span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(PollReadback)(<br>        [Local](FRHICommandListImmediate&amp; RHICmdList)<br>        &#123;<br>            <span class="hljs-type">const</span> uint32 NumBytes = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">2</span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">void</span>* DataPtr = Local-&gt;<span class="hljs-built_in">Lock</span>(NumBytes);<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span>* Values = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">float</span>*&gt;(DataPtr);<br><br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> A = Values[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">const</span> <span class="hljs-type">float</span> B = Values[<span class="hljs-number">1</span>];<br><br>            Local-&gt;<span class="hljs-built_in">Unlock</span>();<br><br>            <span class="hljs-built_in">AsyncTask</span>(ENamedThreads::GameThread, [A, B]()<br>                &#123;<br>                    <span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Readback: %f %f&quot;</span>), A, B);<br>                &#125;);<br>        &#125;<br>        );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AComputeRDGHelper::AddTestComputePass</span><span class="hljs-params">(<span class="hljs-type">float</span> Scale, <span class="hljs-type">float</span> Translate)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AddTestComputePass&quot;</span>));<br><br><span class="hljs-built_in">ENQUEUE_RENDER_COMMAND</span>(AddComputePass)(<br>[Scale, Translate, ReadbackPtr = Readback.<span class="hljs-built_in">Get</span>()](FRHICommandListImmediate&amp; RHICmdList)<br>&#123;<br>FRDGBuilder <span class="hljs-built_in">GraphBuilder</span>(RHICmdList);<br><br>TestShader::<span class="hljs-built_in">AddTestComputePass</span>(GraphBuilder, Scale, Translate, ReadbackPtr);<br><br>GraphBuilder.<span class="hljs-built_in">Execute</span>();<br>&#125;<br>);<br><br>GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">5.0f</span>, FColor::Yellow, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;AddTestComputePassFinish&quot;</span>));<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>与 RDG 相关的操作必须在<strong>渲染线程RenderThread</strong>中执行，如果在<strong>游戏线程GameThread</strong>中直接调用，将导致程序崩溃。因此需要使用<code>ENQUEUE_RENDER_COMMAND()</code>将相关逻辑封装并提交到渲染线程执行。</p><h3 id="在编辑器中创建蓝图">在编辑器中创建蓝图</h3><p>为刚刚编写的 C++ 类创建对应的 UE 蓝图，将其拖入场景中并点击<strong>Simulate</strong> 进行运行。 <img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260124214249038.png" class="">随后查看输出目录，可以发现计算结果已成功从 GPU 回读到 CPU。<img src="/2026/Unreal/RDG%E6%B8%B2%E6%9F%93%E4%BE%9D%E8%B5%96%E5%9B%BE/01-RDG%20%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%BA%BF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/IMG-20260124214329509.png" class=""></p>]]></content>
    
    
    <categories>
      
      <category>虚幻引擎</category>
      
      <category>渲染依赖图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
      <tag>渲染依赖图</tag>
      
      <tag>RDG</tag>
      
      <tag>计算着色器</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
